<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÈñìÂèñ„Çä„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„Éà Pro v6.3</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
            user-select: none;
            overflow: hidden;
        }

        .grid-bg {
            background-color: #f8fafc;
            background-image: radial-gradient(#cbd5e1 1px, transparent 1px);
            background-size: 40px 40px;
        }

        .design-grid {
            background-color: #fff7ed;
            background-image:
                linear-gradient(to right, #fed7aa 1px, transparent 1px),
                linear-gradient(to bottom, #fed7aa 1px, transparent 1px);
            background-size: 20px 20px;
        }

        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .scrollbar-thin::-webkit-scrollbar {
            width: 6px;
        }

        .scrollbar-thin::-webkit-scrollbar-track {
            background: transparent;
        }

        .scrollbar-thin::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 3px;
        }

        /* „Ç≠„É£„É≥„Éê„ÇπÁî®„Çπ„ÇØ„É≠„Éº„É´„Éê„Éº */
        .canvas-scroll::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        .canvas-scroll::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 6px;
        }

        .canvas-scroll::-webkit-scrollbar-thumb {
            background-color: #94a3b8;
            border-radius: 6px;
            border: 2px solid #f1f5f9;
        }

        .canvas-scroll::-webkit-scrollbar-thumb:hover {
            background-color: #64748b;
        }

        .canvas-scroll::-webkit-scrollbar-corner {
            background: #f1f5f9;
        }

        /* ÂÖ±ÈÄöUI„Éë„Éº„ÉÑ */
        .sidebar-header {
            font-size: 0.85rem;
            font-weight: bold;
            color: #4b5563;
            padding: 0.75rem;
            border-bottom: 1px solid #e5e7eb;
            background-color: #f9fafb;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .prop-row {
            display: grid;
            grid-template-columns: 80px 1fr;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .prop-label {
            font-size: 0.75rem;
            font-weight: bold;
            color: #6b7280;
            text-align: right;
        }

        .prop-input {
            width: 100%;
            border: 1px solid #d1d5db;
            border-radius: 0.25rem;
            padding: 0.25rem 0.5rem;
            font-size: 0.85rem;
            text-align: right;
            background-color: white;
        }

        .prop-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .btn-action {
            width: 100%;
            padding: 0.4rem;
            font-size: 0.8rem;
            font-weight: bold;
            border-radius: 0.25rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
        }
    </style>
</head>

<body class="bg-gray-100 h-screen text-gray-700">
    <div id="root" class="h-full flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;
        // --- Ë®≠ÂÆö ---
        const BASE_SCALE = 2.0;
        const SNAP_UNIT = 5;
        const LAYERS = { room: 0, fixture: 1, furniture: 2, text: 3 };
        const toMM = (val) => Math.round(val * 10);
        const fromMM = (val) => val / 10;

        // --- „Ç¢„Ç§„Ç≥„É≥ (SVG) ---
        const Icon = ({ p, size = 18, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{p}</svg>
        );
        const Icons = {
            Home: <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" />,
            Plus: <path d="M12 5v14M5 12h14" />,
            Trash: <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />,
            Move: <path d="M5 9l-3 3 3 3M9 5l3-3 3 3M19 9l3 3-3 3M9 19l3 3 3-3M2 12h20M12 2v20" />,
            Pen: <path d="M12 19l7-7 3 3-7 7-3-3zM18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5zM2 2l7.586 7.586" />,
            Type: <path d="M4 7V4h16v3M9 20h6M12 4v16" />,
            Check: <path d="M20 6L9 17l-5-5" />,
            LogOut: <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4M16 17l5-5-5-5M21 12H9" />,
            Folder: <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z" />,
            ZoomIn: <g><circle cx="11" cy="11" r="8" /><line x1="21" y1="21" x2="16.65" y2="16.65" /><line x1="11" y1="8" x2="11" y2="14" /><line x1="8" y1="11" x2="14" y2="11" /></g>,
            ZoomOut: <g><circle cx="11" cy="11" r="8" /><line x1="21" y1="21" x2="16.65" y2="16.65" /><line x1="8" y1="11" x2="14" y2="11" /></g>,
            Lock: <g><rect x="3" y="11" width="18" height="11" rx="2" ry="2" /><path d="M7 11V7a5 5 0 0 1 10 0v4" /></g>,
            Unlock: <g><rect x="3" y="11" width="18" height="11" rx="2" ry="2" /><path d="M7 11V7a5 5 0 0 1 9.9-1" /></g>,
            Globe: <g><circle cx="12" cy="12" r="10" /><line x1="2" y1="12" x2="22" y2="12" /><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1 4-10z" /></g>,
            Settings: <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.18-.08a2 2 0 0 0-2 0l-.45.45a2 2 0 0 0 0 2l.08.18a2 2 0 0 1 0 2l-.25.43a2 2 0 0 1-1-1.73 1H2a2 2 0 0 0-2 2v.44a2 2 0 0 0 2 2h.18a2 2 0 0 1 1.73 1l.25.43a2 2 0 0 1 0 2l-.08.18a2 2 0 0 0 0 2l.45.45a2 2 0 0 0 2 0l.18-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V2a2 2 0 0 0-2-2z" />,
            Poly: <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5" />,
            Circle: <circle cx="12" cy="12" r="10" />,
            Square: <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />,
            ArrowUpRight: <path d="M7 17l9.2-9.2M17 17V7H7" />,
            Target: <g><circle cx="12" cy="12" r="10" /><line x1="12" y1="8" x2="12" y2="16" /><line x1="8" y1="12" x2="16" y2="12" /></g>,
            Box: <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z" />,
            Copy: <g><rect x="9" y="9" width="13" height="13" rx="2" ry="2" /><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" /></g>,
            Magnet: <g><path d="M6 15v-5a6 6 0 1 1 12 0v5" strokeWidth="2" /><path d="M6 15h4v4h-4z" fill="currentColor" /><path d="M14 15h4v4h-4z" fill="currentColor" /></g>
        };

        // --- API ---
        const API = {
            getAssets: () => fetch('/api/assets').then(r => r.json()).then(res => res.data),
            saveAssets: (d) => fetch('/api/assets', { method: 'POST', body: JSON.stringify(d) }).then(r => r.json()),
            getPalette: () => fetch('/api/palette').then(r => r.json()).then(res => res.data),
            savePalette: (d) => fetch('/api/palette', { method: 'POST', body: JSON.stringify(d) }).then(r => r.json()),
            getProjects: () => fetch('/api/projects').then(r => r.json()).then(res => res.data),
            createProject: (name) => fetch('/api/projects', { method: 'POST', body: JSON.stringify({ name }) }).then(r => r.json()).then(res => res.data),
            getProjectData: (id) => fetch(`/api/projects/${id}`).then(r => r.json()).then(res => res.data),
            saveProjectData: (id, d) => fetch(`/api/projects/${id}`, { method: 'PUT', body: JSON.stringify(d) }).then(r => r.json()),
            deleteProject: (id) => fetch(`/api/projects/${id}`, { method: 'DELETE' }).then(r => r.json()),
            updateProjectName: (id, name) => fetch(`/api/projects/${id}`, { method: 'PATCH', body: JSON.stringify({ name }) }).then(r => r.json()),
        };

        // --- Utils ---
        const createRectPath = (w, h, x = 0, y = 0) => [
            { x: x, y: y, h1: { x: 0, y: 0 }, h2: { x: 0, y: 0 }, isCurve: false },
            { x: x + w, y: y, h1: { x: 0, y: 0 }, h2: { x: 0, y: 0 }, isCurve: false },
            { x: x + w, y: y + h, h1: { x: 0, y: 0 }, h2: { x: 0, y: 0 }, isCurve: false },
            { x: x, y: y + h, h1: { x: 0, y: 0 }, h2: { x: 0, y: 0 }, isCurve: false },
        ];
        const createTrianglePath = (w, h, x = 0, y = 0) => [
            { x: x + w / 2, y: y, h1: { x: 0, y: 0 }, h2: { x: 0, y: 0 }, isCurve: false },
            { x: x + w, y: y + h, h1: { x: 0, y: 0 }, h2: { x: 0, y: 0 }, isCurve: false },
            { x: x, y: y + h, h1: { x: 0, y: 0 }, h2: { x: 0, y: 0 }, isCurve: false },
        ];
        const normalizeAsset = (asset) => {
            if (!asset) return null;
            let shapes = asset.shapes || [];
            if (shapes.length === 0) {
                if (asset.shape === 'rect' || !asset.shape) {
                    shapes.push({ type: 'polygon', points: createRectPath(asset.w || 60, asset.h || 60), color: asset.color });
                } else if (asset.shape === 'polygon' && asset.points) {
                    const pts = asset.points.map(p => ({ x: p.x, y: p.y, h1: { x: 0, y: 0 }, h2: { x: 0, y: 0 }, isCurve: false }));
                    shapes.push({ type: 'polygon', points: pts, color: asset.color });
                } else if (asset.shape === 'circle') {
                    shapes.push({ type: 'circle', x: 0, y: 0, w: asset.w || 60, h: asset.h || 60, color: asset.color });
                }
            }
            return { ...asset, shapes, w: asset.w || 60, h: asset.h || 60 };
        };

        // Êñ∞„Åó„ÅÑ„Éë„ÇπÁîüÊàêÔºöhandlesÈÖçÂàóÂØæÂøú
        // handles: [] = Áõ¥Á∑ö, handles: [{x,y}] = ‰∫åÊ¨°„Éô„Ç∏„Çß, handles: [{x,y},{x,y}] = ‰∏âÊ¨°„Éô„Ç∏„Çß, „Åù„Çå‰ª•‰∏ä = ÈÄ£Á∂öÊõ≤Á∑ö
        const generateSvgPath = (points) => {
            if (!points || points.length === 0) return "";
            let d = `M ${points[0].x * BASE_SCALE} ${points[0].y * BASE_SCALE}`;
            for (let i = 0; i < points.length; i++) {
                const curr = points[i];
                const next = points[(i + 1) % points.length];
                const handles = curr.handles || [];

                if (handles.length === 0) {
                    // ÊóßÂΩ¢Âºè„Å®„ÅÆ‰∫íÊèõ: isCurve/h1/h2„Åå„ÅÇ„ÇãÂ†¥Âêà
                    if (curr.isCurve || next.isCurve) {
                        const cp1x = (curr.x + (curr.h2?.x || 0)) * BASE_SCALE;
                        const cp1y = (curr.y + (curr.h2?.y || 0)) * BASE_SCALE;
                        const cp2x = (next.x + (next.h1?.x || 0)) * BASE_SCALE;
                        const cp2y = (next.y + (next.h1?.y || 0)) * BASE_SCALE;
                        d += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${next.x * BASE_SCALE} ${next.y * BASE_SCALE}`;
                    } else {
                        d += ` L ${next.x * BASE_SCALE} ${next.y * BASE_SCALE}`;
                    }
                } else if (handles.length === 1) {
                    // ‰∫åÊ¨°„Éô„Ç∏„ÇßÊõ≤Á∑ö (Q)
                    const h = handles[0];
                    d += ` Q ${h.x * BASE_SCALE} ${h.y * BASE_SCALE}, ${next.x * BASE_SCALE} ${next.y * BASE_SCALE}`;
                } else if (handles.length === 2) {
                    // ‰∏âÊ¨°„Éô„Ç∏„ÇßÊõ≤Á∑ö (C)
                    const h1 = handles[0];
                    const h2 = handles[1];
                    d += ` C ${h1.x * BASE_SCALE} ${h1.y * BASE_SCALE}, ${h2.x * BASE_SCALE} ${h2.y * BASE_SCALE}, ${next.x * BASE_SCALE} ${next.y * BASE_SCALE}`;
                } else {
                    // Ë§áÊï∞„ÅÆ„Éè„É≥„Éâ„É´: ÈÄ£Á∂öÊõ≤Á∑ö„Å®„Åó„Å¶ÊèèÁîª
                    const step = 1 / handles.length;
                    let lastX = curr.x, lastY = curr.y;
                    for (let j = 0; j < handles.length; j++) {
                        const h = handles[j];
                        const t = (j + 1) * step;
                        const endX = curr.x + (next.x - curr.x) * t;
                        const endY = curr.y + (next.y - curr.y) * t;
                        d += ` Q ${h.x * BASE_SCALE} ${h.y * BASE_SCALE}, ${endX * BASE_SCALE} ${endY * BASE_SCALE}`;
                        lastX = endX; lastY = endY;
                    }
                    // ÊúÄÂæå„ÅÆÁÇπ„Å∏Áõ¥Á∑ö
                    if (Math.abs(lastX - next.x) > 0.01 || Math.abs(lastY - next.y) > 0.01) {
                        d += ` L ${next.x * BASE_SCALE} ${next.y * BASE_SCALE}`;
                    }
                }
            }
            d += " Z";
            return d;
        };

        // Áµ±‰∏ÄÊ•ïÂÜÜSVG„Éë„ÇπÁîüÊàêÔºàÊ•ïÂÜÜ„ÉªÊâáÂΩ¢„ÉªÂºìÂΩ¢ÂØæÂøúÔºâ
        const generateEllipsePath = (shape) => {
            const { cx = 0, cy = 0, rx = 50, ry = 50, startAngle = 0, endAngle = 360, arcMode = 'sector', rotation = 0 } = shape;
            const rxs = rx * BASE_SCALE;
            const rys = ry * BASE_SCALE;
            const cxs = cx * BASE_SCALE;
            const cys = cy * BASE_SCALE;

            // ÂÆåÂÖ®„Å™Ê•ïÂÜÜ„ÅÆÂ†¥Âêà
            const angleDiff = ((endAngle - startAngle + 360) % 360) || 360;
            if (angleDiff >= 360) {
                // ÂÆåÂÖ®„Å™Ê•ïÂÜÜ„ÅØ2„Å§„ÅÆÂÜÜÂºß„ÅßÊèèÁîª
                return `M ${cxs - rxs} ${cys} A ${rxs} ${rys} 0 1 1 ${cxs + rxs} ${cys} A ${rxs} ${rys} 0 1 1 ${cxs - rxs} ${cys}`;
            }

            // ÈÉ®ÂàÜÂÜÜÂºß„ÅÆÂ†¥Âêà
            const startRad = (startAngle * Math.PI) / 180;
            const endRad = (endAngle * Math.PI) / 180;

            // Ê•ïÂÜÜ‰∏ä„ÅÆÂßãÁÇπ„ÉªÁµÇÁÇπ
            const x1 = cxs + rxs * Math.cos(startRad);
            const y1 = cys + rys * Math.sin(startRad);
            const x2 = cxs + rxs * Math.cos(endRad);
            const y2 = cys + rys * Math.sin(endRad);

            const largeArc = angleDiff > 180 ? 1 : 0;
            const sweepFlag = 1;

            if (arcMode === 'sector') {
                // ÊâáÂΩ¢: ‰∏≠ÂøÉ‚ÜíÂßãÁÇπ‚ÜíÂÜÜÂºß‚ÜíÁµÇÁÇπ‚Üí‰∏≠ÂøÉ
                return `M ${cxs} ${cys} L ${x1} ${y1} A ${rxs} ${rys} 0 ${largeArc} ${sweepFlag} ${x2} ${y2} Z`;
            } else {
                // ÂºìÂΩ¢(chord): ÂßãÁÇπ‚ÜíÂÜÜÂºß‚ÜíÁµÇÁÇπ‚ÜíÂßãÁÇπ
                return `M ${x1} ${y1} A ${rxs} ${rys} 0 ${largeArc} ${sweepFlag} ${x2} ${y2} Z`;
            }
        };

        const getClientPos = (e, viewState, svgRect) => {
            const cx = e.clientX - svgRect.left;
            const cy = e.clientY - svgRect.top;
            const x = (cx - viewState.x) / viewState.scale / BASE_SCALE;
            const y = (cy - viewState.y) / viewState.scale / BASE_SCALE;
            return { x, y };
        };

        // --- Common Leaf Components ---

        const RenderAssetShapes = ({ item, isSelected }) => {
            const shapes = (item.shapes && item.shapes.length > 0)
                ? item.shapes
                : [{ type: item.shape || 'rect', w: item.w, h: item.h, x: 0, y: 0, color: item.color, points: item.points || createRectPath(item.w, item.h) }];
            return (
                <g>
                    {shapes.map((s, i) => {
                        const style = { fill: s.color || item.color, stroke: isSelected ? "#3b82f6" : "#999", strokeWidth: isSelected ? 3 : 1 };
                        const rot = s.rotation || 0;
                        const rotateTransform = rot ? `rotate(${rot} ${(s.cx || 0) * BASE_SCALE} ${(s.cy || 0) * BASE_SCALE})` : '';
                        if (s.type === 'circle') return <ellipse key={i} cx={(s.x + s.w / 2) * BASE_SCALE} cy={(s.y + s.h / 2) * BASE_SCALE} rx={s.w * BASE_SCALE / 2} ry={s.h * BASE_SCALE / 2} {...style} />;
                        if (s.type === 'ellipse') return <path key={i} d={generateEllipsePath(s)} transform={rotateTransform} {...style} />;
                        if (s.type === 'polygon' && s.points) return <path key={i} d={generateSvgPath(s.points)} {...style} />;
                        return <rect key={i} x={s.x * BASE_SCALE} y={s.y * BASE_SCALE} width={s.w * BASE_SCALE} height={s.h * BASE_SCALE} rx={2} {...style} />;
                    })}
                </g>
            );
        };

        const RenderItem = ({ item, isSelected, onDown }) => (
            <g
                transform={`translate(${item.x * BASE_SCALE}, ${item.y * BASE_SCALE}) rotate(${item.rotation})`}
                onPointerDown={e => { e.stopPropagation(); onDown(e, item.id); }}
                className="hover:opacity-90"
                style={{ cursor: 'grab', opacity: isSelected ? 0.85 : 1 }}
            >
                {item.type === 'text' ? (
                    <g>
                        {isSelected && <rect x="-5" y="-25" width="100" height="35" fill="rgba(59,130,246,0.1)" stroke="#3b82f6" strokeWidth="2" strokeDasharray="4" />}
                        <text fill={item.color} fontSize={item.fontSize} fontWeight="bold" style={{ whiteSpace: 'pre', userSelect: 'none' }}>{item.text}</text>
                    </g>
                ) : (
                    <g>
                        <RenderAssetShapes item={item} isSelected={isSelected} />
                        {isSelected && <g className="pointer-events-none">
                            {/* ‰ΩçÁΩÆË°®Á§∫ (ÂéüÁÇπ„Åã„Çâ„ÅÆË∑ùÈõ¢) */}
                            <text x={-15} y={-15} textAnchor="end" fontSize="9" fill="#666" fontWeight="bold">({toMM(item.x)}, {toMM(item.y)})</text>
                            {/* „Çµ„Ç§„Ç∫Ë°®Á§∫ */}
                            <line x1={0} y1={-10} x2={item.w * BASE_SCALE} y2={-10} stroke="blue" strokeWidth="1" />
                            <text x={item.w * BASE_SCALE / 2} y={-12} textAnchor="middle" fontSize="10" fill="blue">{toMM(item.w)}mm</text>
                            <line x1={-10} y1={0} x2={-10} y2={item.h * BASE_SCALE} stroke="blue" strokeWidth="1" />
                            <text x={-12} y={item.h * BASE_SCALE / 2} textAnchor="end" dominantBaseline="middle" fontSize="10" fill="blue">{toMM(item.h)}mm</text>
                            {/* ÈÅ∏Êäû„Éè„Ç§„É©„Ç§„Éà */}
                            <rect x={-2} y={-2} width={item.w * BASE_SCALE + 4} height={item.h * BASE_SCALE + 4} fill="none" stroke="#3b82f6" strokeWidth="2" strokeDasharray="6 3" />
                        </g>}
                        <text x={item.w * BASE_SCALE / 2} y={item.h * BASE_SCALE / 2} textAnchor="middle" dominantBaseline="middle" fontSize={12} fill="#333" pointerEvents="none" style={{ userSelect: 'none', textShadow: '0 0 2px white' }}>{item.name}</text>
                    </g>
                )}
            </g>
        );

        const Ruler = ({ viewState }) => {
            const width = 3000;
            const height = 3000; const step = 100;
            const offsetX = viewState.x; const offsetY = viewState.y;
            const scale = viewState.scale * BASE_SCALE;
            const xTicks = []; const yTicks = [];
            for (let i = 0; i < width; i += step) {
                const x = offsetX + i * scale;
                if (x > 20) xTicks.push(<g key={`x${i}`}><line x1={x} y1={0} x2={x} y2={15} stroke="#888" strokeWidth="1" /><text x={x + 2} y={12} fontSize="10" fill="#555">{i}</text></g>);
            }
            for (let i = 0; i < height; i += step) {
                const y = offsetY + i * scale;
                if (y > 20) yTicks.push(<g key={`y${i}`}><line x1={0} y1={y} x2={15} y2={y} stroke="#888" strokeWidth="1" /><text x={2} y={y + 10} fontSize="10" fill="#555">{i}</text></g>);
            }
            return (
                <div className="absolute inset-0 pointer-events-none z-0">
                    <svg width="100%" height="20" className="absolute top-0 left-0 bg-white/90 border-b z-10">{xTicks}</svg>
                    <svg width="20" height="100%" className="absolute top-0 left-0 bg-white/90 border-r z-10">{yTicks}</svg>
                </div>
            );
        };

        const ProjectCard = ({ project, onOpen, onDelete, onRename }) => {
            const [name, setName] = useState(project.name);
            useEffect(() => setName(project.name), [project.name]);
            const handleBlur = () => { if (name !== project.name) onRename(project.id, name); };
            const handleKeyDown = (e) => { if (e.key === 'Enter') e.currentTarget.blur(); };
            return (
                <div onClick={onOpen} className="h-40 bg-white border rounded-lg shadow-sm hover:shadow-md p-4 flex flex-col cursor-pointer relative group transition">
                    <div className="flex-1 flex flex-col items-center justify-center">
                        <Icon p={Icons.Folder} size={40} className="text-orange-200 mb-2" />
                        <input value={name} onClick={e => e.stopPropagation()} onChange={e => setName(e.target.value)} onBlur={handleBlur} onKeyDown={handleKeyDown} className="text-center font-bold text-lg w-full bg-transparent border-b border-transparent focus:border-blue-500 outline-none text-gray-700" />
                    </div>
                    <button onClick={(e) => onDelete(e, project.id)} className="absolute top-2 right-2 p-2 text-gray-300 hover:text-red-500 opacity-0 group-hover:opacity-100 transition"><Icon p={Icons.Trash} /></button>
                </div>
            );
        };
        const EditableTitle = ({ name, onRename }) => {
            const [val, setVal] = useState(name);
            useEffect(() => setVal(name), [name]);
            const handleBlur = () => { if (val !== name) onRename(val); };
            const handleKeyDown = (e) => { if (e.key === 'Enter') e.currentTarget.blur(); };
            return <input value={val} onChange={e => setVal(e.target.value)} onBlur={handleBlur} onKeyDown={handleKeyDown} className="font-bold text-lg text-gray-800 bg-transparent border-b border-transparent hover:border-gray-300 focus:border-blue-500 outline-none px-1" style={{ minWidth: '200px' }} />;
        };

        const AssetFilter = ({ filter, setFilter }) => (
            <div className="flex p-2 gap-1 bg-gray-50 border-b shrink-0">
                <button onClick={() => setFilter('local')} className={`flex-1 py-1 text-[10px] rounded border transition ${filter === 'local' ? 'bg-white border-orange-300 shadow-sm font-bold text-orange-600' : 'border-transparent text-gray-400 hover:bg-gray-100'}`}>„É≠„Éº„Ç´„É´</button>
                <button onClick={() => setFilter('global')} className={`flex-1 py-1 text-[10px] rounded border transition ${filter === 'global' ? 'bg-white border-blue-300 shadow-sm font-bold text-blue-600' : 'border-transparent text-gray-400 hover:bg-gray-100'}`}>ÂÖ±ÈÄö</button>
            </div>
        );

        // --- „Ç´„É©„Éº„Éî„ÉÉ„Ç´„Éº „Ç≥„É≥„Éù„Éº„Éç„É≥„Éà ---
        const ColorPicker = ({ value, onChange, palette, onAddToPalette }) => {
            const [showMore, setShowMore] = useState(false);
            const [showCustom, setShowCustom] = useState(false);
            const [customColor, setCustomColor] = useState(value || '#cccccc');

            const handleCustomChange = (e) => {
                setCustomColor(e.target.value);
                onChange(e.target.value);
            };

            const handleAddToPalette = () => {
                if (onAddToPalette && !palette.includes(customColor)) {
                    onAddToPalette(customColor);
                }
            };

            const colors = palette || [];
            const firstRow = colors.slice(0, 5);
            const moreColors = colors.slice(5);

            return (
                <div className="space-y-1">
                    {/* 1Ë°åÁõÆ: ÊúÄÂàù„ÅÆ5Ëâ≤ */}
                    <div className="flex gap-1 items-center">
                        {firstRow.map((color, i) => (
                            <button
                                key={i}
                                onClick={() => { onChange(color); setShowMore(false); }}
                                className={`w-6 h-6 rounded border-2 transition hover:scale-110 ${value === color ? 'border-blue-500 ring-2 ring-blue-200' : 'border-gray-300'}`}
                                style={{ backgroundColor: color }}
                                title={color}
                            />
                        ))}
                        {moreColors.length > 0 && (
                            <button
                                onClick={() => setShowMore(!showMore)}
                                className="w-6 h-6 rounded border-2 border-dashed border-gray-300 text-gray-400 text-[10px] hover:border-blue-400 hover:text-blue-500"
                                title={showMore ? 'Èñâ„Åò„Çã' : '„ÇÇ„Å£„Å®Ë¶ã„Çã'}
                            >
                                {showMore ? '‚àí' : `+${moreColors.length}`}
                            </button>
                        )}
                        <button
                            onClick={() => setShowCustom(!showCustom)}
                            className="w-6 h-6 rounded border-2 border-dashed border-gray-300 flex items-center justify-center hover:border-blue-400"
                            title="„Ç´„Çπ„Çø„É†Ëâ≤"
                        >
                            <span className="text-[10px]">üé®</span>
                        </button>
                    </div>

                    {/* Â±ïÈñãÊôÇ: ÊÆã„Çä„ÅÆËâ≤ */}
                    {showMore && moreColors.length > 0 && (
                        <div className="grid grid-cols-5 gap-1 p-2 bg-gray-50 rounded border">
                            {moreColors.map((color, i) => (
                                <button
                                    key={i}
                                    onClick={() => { onChange(color); setShowMore(false); }}
                                    className={`w-6 h-6 rounded border-2 transition hover:scale-110 ${value === color ? 'border-blue-500 ring-2 ring-blue-200' : 'border-gray-300'}`}
                                    style={{ backgroundColor: color }}
                                    title={color}
                                />
                            ))}
                        </div>
                    )}

                    {/* „Ç´„Çπ„Çø„É†„Ç´„É©„Éº */}
                    {showCustom && (
                        <div className="flex gap-2 items-center p-2 bg-gray-50 rounded border">
                            <input
                                type="color"
                                value={customColor}
                                onChange={handleCustomChange}
                                className="w-8 h-6 cursor-pointer border rounded"
                            />
                            <button
                                onClick={handleAddToPalette}
                                className="text-[10px] px-2 py-0.5 bg-green-50 text-green-600 border border-green-200 rounded hover:bg-green-100"
                                title="„Éë„É¨„ÉÉ„Éà„Å´ËøΩÂä†"
                            >
                                +ËøΩÂä†
                            </button>
                            <button
                                onClick={() => setShowCustom(false)}
                                className="text-[10px] text-gray-400 hover:text-gray-600"
                            >
                                Èñâ„Åò„Çã
                            </button>
                        </div>
                    )}
                </div>
            );
        };

        // --- Canvas Components ---

        const DesignCanvasRender = ({ viewState, asset, shapes, selectedShapeIndex, selectedPointIndex, onDown, onMove, onUp, onDeleteShape, svgRef }) => (
            <div className="w-full h-full absolute top-0 left-0 overflow-auto canvas-scroll pt-5 pl-5"
                onPointerDown={e => onDown(e, null)}
                onPointerMove={onMove}
                onPointerUp={onUp}
                ref={svgRef}
            >
                <svg width="3000" height="3000" style={{ minWidth: '3000px', minHeight: '3000px' }}>
                    <g transform={`translate(${viewState.x}, ${viewState.y}) scale(${viewState.scale})`}>
                        <line x1="-5000" y1="0" x2="5000" y2="0" stroke="#ccc" strokeWidth="2" />
                        <line x1="0" y1="-5000" x2="0" y2="5000" stroke="#ccc" strokeWidth="2" />
                        <circle cx="0" cy="0" r="5" fill="red" opacity="0.5" />
                        {asset && (
                            <g>
                                <rect x="0" y="0" width={asset.w * BASE_SCALE} height={asset.h * BASE_SCALE} fill="none" stroke="blue" strokeWidth="1" strokeDasharray="4 2" opacity="0.3" pointerEvents="none" />
                                {shapes.map((s, i) => {
                                    const isSelected = (selectedShapeIndex === i);
                                    const style = { fill: s.color || asset.color, stroke: isSelected ? "#3b82f6" : "#999", strokeWidth: isSelected ? 2 : 1, cursor: 'move' };
                                    const rot = s.rotation || 0;
                                    const rotateTransform = rot && s.type === 'ellipse' ? `rotate(${rot} ${(s.cx || 0) * BASE_SCALE} ${(s.cy || 0) * BASE_SCALE})` : '';
                                    return (
                                        <g key={i} onPointerDown={(e) => onDown(e, i)}>
                                            {s.type === 'circle'
                                                ? <ellipse cx={(s.x + s.w / 2) * BASE_SCALE} cy={(s.y + s.h / 2) * BASE_SCALE} rx={s.w * BASE_SCALE / 2} ry={s.h * BASE_SCALE / 2} {...style} />
                                                : s.type === 'ellipse'
                                                    ? <path d={generateEllipsePath(s)} transform={rotateTransform} {...style} />
                                                    : <path d={generateSvgPath(s.points)} {...style} />
                                            }
                                            {/* Ê•ïÂÜÜ„ÅÆÁ∑®ÈõÜ„Éè„É≥„Éâ„É´ */}
                                            {isSelected && s.type === 'ellipse' && (() => {
                                                const cx = (s.cx || 0) * BASE_SCALE;
                                                const cy = (s.cy || 0) * BASE_SCALE;
                                                const rxs = (s.rx || 50) * BASE_SCALE;
                                                const rys = (s.ry || 50) * BASE_SCALE;
                                                const startAngle = s.startAngle || 0;
                                                const endAngle = s.endAngle || 360;
                                                const startRad = startAngle * Math.PI / 180;
                                                const endRad = endAngle * Math.PI / 180;
                                                const sx = cx + rxs * Math.cos(startRad);
                                                const sy = cy + rys * Math.sin(startRad);
                                                const ex = cx + rxs * Math.cos(endRad);
                                                const ey = cy + rys * Math.sin(endRad);
                                                // ÂõûËª¢„Éè„É≥„Éâ„É´‰ΩçÁΩÆÔºà‰∏äÈÉ®Ôºâ
                                                const rotHandleY = cy - rys - 20;
                                                return (
                                                    <g transform={rotateTransform}>
                                                        {/* ‰∏≠ÂøÉÁÇπ */}
                                                        <circle cx={cx} cy={cy} r="6" fill="red" stroke="white" strokeWidth="2" className="cursor-move" />
                                                        {/* Ê®™ÂçäÂæÑ„Éè„É≥„Éâ„É´ÔºàÂè≥Ôºâ- ÁÇπÁ∑ö„Å™„Åó */}
                                                        <rect x={cx + rxs - 4} y={cy - 4} width="8" height="8" fill="orange" stroke="white" strokeWidth="1" className="cursor-ew-resize" onPointerDown={(e) => onDown(e, i, 'rx')} />
                                                        {/* Á∏¶ÂçäÂæÑ„Éè„É≥„Éâ„É´Ôºà‰∏ãÔºâ- ÁÇπÁ∑ö„Å™„Åó */}
                                                        <rect x={cx - 4} y={cy + rys - 4} width="8" height="8" fill="orange" stroke="white" strokeWidth="1" className="cursor-ns-resize" onPointerDown={(e) => onDown(e, i, 'ry')} />
                                                        {/* ÊØîÁéáÁ∂≠ÊåÅ„Éè„É≥„Éâ„É´ÔºàÂè≥‰∏ãÔºâ */}
                                                        <rect x={cx + rxs - 4} y={cy + rys - 4} width="8" height="8" fill="yellow" stroke="orange" strokeWidth="1" className="cursor-nwse-resize" onPointerDown={(e) => onDown(e, i, 'rxy')} />
                                                        {/* ÂõûËª¢„Éè„É≥„Éâ„É´ */}
                                                        <line x1={cx} y1={cy - rys} x2={cx} y2={rotHandleY} stroke="cyan" strokeWidth="1" strokeDasharray="3,2" />
                                                        <circle cx={cx} cy={rotHandleY} r="5" fill="cyan" stroke="white" strokeWidth="1" className="cursor-pointer" onPointerDown={(e) => onDown(e, i, 'rotation')} />
                                                        {/* ËßíÂ∫¶„Éè„É≥„Éâ„É´Ôºà60%„ÅÆ‰ΩçÁΩÆ„Å´ÈÖçÁΩÆ„Åó„Å¶ÂàÜÈõ¢Ôºâ */}
                                                        <line x1={cx} y1={cy} x2={sx * 0.6 + cx * 0.4} y2={sy * 0.6 + cy * 0.4} stroke="green" strokeWidth="1" strokeDasharray="3,2" />
                                                        <line x1={cx} y1={cy} x2={ex * 0.6 + cx * 0.4} y2={ey * 0.6 + cy * 0.4} stroke="purple" strokeWidth="1" strokeDasharray="3,2" />
                                                        <circle cx={sx * 0.6 + cx * 0.4} cy={sy * 0.6 + cy * 0.4} r="5" fill="green" stroke="white" strokeWidth="1" className="cursor-pointer" onPointerDown={(e) => onDown(e, i, 'startAngle')} />
                                                        <circle cx={ex * 0.6 + cx * 0.4} cy={ey * 0.6 + cy * 0.4} r="5" fill="purple" stroke="white" strokeWidth="1" className="cursor-pointer" onPointerDown={(e) => onDown(e, i, 'endAngle')} />
                                                    </g>
                                                );
                                            })()}
                                            {isSelected && s.type === 'polygon' && s.points.map((p, pid) => (
                                                <React.Fragment key={pid}>
                                                    {/* È†ÇÁÇπ */}
                                                    <circle cx={p.x * BASE_SCALE} cy={p.y * BASE_SCALE} r="5" fill={selectedPointIndex === pid ? "red" : "white"} stroke="blue" strokeWidth="2" className="cursor-crosshair" onPointerDown={(e) => onDown(e, i, pid)} />
                                                    {/* Âà∂Âæ°ÁÇπ */}
                                                    {p.handles && p.handles.map((h, hid) => (
                                                        <React.Fragment key={`h-${pid}-${hid}`}>
                                                            <line x1={p.x * BASE_SCALE} y1={p.y * BASE_SCALE} x2={h.x * BASE_SCALE} y2={h.y * BASE_SCALE} stroke="orange" strokeWidth="1" strokeDasharray="3,2" />
                                                            <rect x={h.x * BASE_SCALE - 4} y={h.y * BASE_SCALE - 4} width="8" height="8" fill="orange" stroke="darkorange" strokeWidth="1" className="cursor-move" onPointerDown={(e) => onDown(e, i, pid, null, hid)} />
                                                        </React.Fragment>
                                                    ))}
                                                </React.Fragment>
                                            ))}
                                            {isSelected && s.type === 'polygon' && (() => {
                                                const maxX = Math.max(...s.points.map(p => p.x));
                                                const minY = Math.min(...s.points.map(p => p.y));
                                                return (
                                                    <g transform={`translate(${maxX * BASE_SCALE + 10}, ${minY * BASE_SCALE - 10})`} className="cursor-pointer" onPointerDown={(e) => onDeleteShape(e, i)}>
                                                        <circle r="8" fill="red" />
                                                        <line x1="-4" y1="-4" x2="4" y2="4" stroke="white" strokeWidth="2" /><line x1="4" y1="-4" x2="-4" y2="4" stroke="white" strokeWidth="2" />
                                                    </g>
                                                );
                                            })()}
                                            {isSelected && (s.type === 'circle' || s.type === 'rect') && (
                                                <g>
                                                    <rect x={(s.x + s.w - 5 / BASE_SCALE) * BASE_SCALE} y={(s.y + s.h - 5 / BASE_SCALE) * BASE_SCALE} width="10" height="10" fill="yellow" stroke="blue" strokeWidth="2" className="cursor-nwse-resize" onPointerDown={(e) => onDown(e, i, null, 'both')} />
                                                    <rect x={(s.x + s.w - 5 / BASE_SCALE) * BASE_SCALE} y={(s.y + s.h / 2 - 5 / BASE_SCALE) * BASE_SCALE} width="10" height="10" fill="lightblue" stroke="blue" strokeWidth="2" className="cursor-ew-resize" onPointerDown={(e) => onDown(e, i, null, 'horizontal')} />
                                                    <rect x={(s.x + s.w / 2 - 5 / BASE_SCALE) * BASE_SCALE} y={(s.y + s.h - 5 / BASE_SCALE) * BASE_SCALE} width="10" height="10" fill="lightgreen" stroke="blue" strokeWidth="2" className="cursor-ns-resize" onPointerDown={(e) => onDown(e, i, null, 'vertical')} />
                                                    <g transform={`translate(${(s.x + s.w) * BASE_SCALE + 10}, ${s.y * BASE_SCALE - 10})`} className="cursor-pointer" onPointerDown={(e) => onDeleteShape(e, i)}>
                                                        <circle r="8" fill="red" />
                                                        <line x1="-4" y1="-4" x2="4" y2="4" stroke="white" strokeWidth="2" /><line x1="4" y1="-4" x2="-4" y2="4" stroke="white" strokeWidth="2" />
                                                    </g>
                                                </g>
                                            )}
                                        </g>
                                    );
                                })}
                            </g>
                        )}
                    </g>
                </svg>
            </div>
        );

        const DesignCanvas = ({ viewState, setViewState, assets, designTargetId, setLocalAssets, selectedShapeIndex, setSelectedShapeIndex, selectedPointIndex, setSelectedPointIndex }) => {
            const dragRef = useRef({ mode: 'idle' });
            const [cursorMode, setCursorMode] = useState('idle');
            const svgRef = useRef(null);
            const asset = assets.find(a => a.id === designTargetId);

            const handleDown = (e, shapeIndex = null, pointIndex = null, resizeMode = null, handleIndex = null) => {
                if (svgRef.current && e.pointerId) svgRef.current.setPointerCapture(e.pointerId);
                const rect = svgRef.current.getBoundingClientRect();

                // „Ç≠„É£„É≥„Éê„ÇπÂÖ®‰Ωì„ÅÆÁßªÂãïÔºàËÉåÊôØ„ÇØ„É™„ÉÉ„ÇØ„Åæ„Åü„ÅØ‰∏≠„Éú„Çø„É≥Ôºâ
                if (shapeIndex === null || e.button === 1) {
                    dragRef.current = { mode: 'panning', sx: e.clientX, sy: e.clientY, vx: viewState.x, vy: viewState.y };
                    setCursorMode('panning');
                    return;
                }

                // „É™„Çµ„Ç§„Ç∫„Éè„É≥„Éâ„É´„Éâ„É©„ÉÉ„Ç∞
                if (resizeMode && shapeIndex !== null) {
                    e.stopPropagation();
                    setSelectedShapeIndex(shapeIndex);
                    setSelectedPointIndex(null);
                    const shape = asset.shapes[shapeIndex];
                    dragRef.current = {
                        mode: 'resizing',
                        sx: e.clientX, sy: e.clientY,
                        shapeW: shape.w, shapeH: shape.h,
                        shapeX: shape.x || 0, shapeY: shape.y || 0,
                        resizeMode
                    };
                    setCursorMode('resizing');
                    return;
                }

                // Âà∂Âæ°ÁÇπÔºà„Éè„É≥„Éâ„É´Ôºâ„Éâ„É©„ÉÉ„Ç∞
                if (handleIndex !== null && pointIndex !== null && shapeIndex !== null) {
                    e.stopPropagation();
                    setSelectedShapeIndex(shapeIndex);
                    setSelectedPointIndex(pointIndex);
                    const shape = asset.shapes[shapeIndex];
                    const handle = shape.points[pointIndex].handles[handleIndex];
                    dragRef.current = { mode: 'draggingHandle', sx: e.clientX, sy: e.clientY, handleX: handle.x, handleY: handle.y, handleIndex };
                    setCursorMode('draggingHandle');
                    return;
                }

                // ËßíÂ∫¶„Éè„É≥„Éâ„É´„Éâ„É©„ÉÉ„Ç∞ÔºàÂÜÜÂºßÁî®Ôºâ
                if ((pointIndex === 'startAngle' || pointIndex === 'endAngle') && shapeIndex !== null) {
                    e.stopPropagation();
                    setSelectedShapeIndex(shapeIndex);
                    const shape = asset.shapes[shapeIndex];
                    const rect = svgRef.current.getBoundingClientRect();
                    dragRef.current = {
                        mode: 'draggingAngle',
                        angleType: pointIndex,
                        shapeCX: (shape.cx || 0),
                        shapeCY: (shape.cy || 0),
                        shapeRotation: shape.rotation || 0,
                        rect: rect
                    };
                    setCursorMode('draggingAngle');
                    return;
                }

                // ÂõûËª¢„Éè„É≥„Éâ„É´„Éâ„É©„ÉÉ„Ç∞
                if (pointIndex === 'rotation' && shapeIndex !== null) {
                    e.stopPropagation();
                    setSelectedShapeIndex(shapeIndex);
                    const shape = asset.shapes[shapeIndex];
                    const rect = svgRef.current.getBoundingClientRect();
                    dragRef.current = {
                        mode: 'draggingRotation',
                        shapeCX: (shape.cx || 0),
                        shapeCY: (shape.cy || 0),
                        initialRotation: shape.rotation || 0,
                        rect: rect
                    };
                    setCursorMode('draggingRotation');
                    return;
                }

                // ÂçäÂæÑ„Éè„É≥„Éâ„É´„Éâ„É©„ÉÉ„Ç∞Ôºàrx/ry/rxyÔºâ
                if ((pointIndex === 'rx' || pointIndex === 'ry' || pointIndex === 'rxy') && shapeIndex !== null) {
                    e.stopPropagation();
                    setSelectedShapeIndex(shapeIndex);
                    const shape = asset.shapes[shapeIndex];
                    const rect = svgRef.current.getBoundingClientRect();
                    dragRef.current = {
                        mode: 'draggingRadius',
                        radiusType: pointIndex,
                        shapeCX: (shape.cx || 0),
                        shapeCY: (shape.cy || 0),
                        initialRx: shape.rx || 50,
                        initialRy: shape.ry || 50,
                        rect: rect
                    };
                    setCursorMode('draggingRadius');
                    return;
                }

                // È†ÇÁÇπ„Éâ„É©„ÉÉ„Ç∞
                if (pointIndex !== null && shapeIndex !== null) {
                    e.stopPropagation();
                    setSelectedShapeIndex(shapeIndex);
                    setSelectedPointIndex(pointIndex);
                    const shape = asset.shapes ? asset.shapes[shapeIndex] : { points: [] };
                    const point = shape.points[pointIndex];
                    dragRef.current = { mode: 'draggingPoint', sx: e.clientX, sy: e.clientY, pointX: point.x, pointY: point.y };
                    setCursorMode('draggingPoint');
                    return;
                }

                // „Ç∑„Çß„Ç§„Éó„Éâ„É©„ÉÉ„Ç∞
                if (shapeIndex !== null) {
                    e.stopPropagation();
                    setSelectedShapeIndex(shapeIndex);
                    setSelectedPointIndex(null);
                    const shape = (asset.shapes && asset.shapes[shapeIndex]) || { x: 0, y: 0, w: 60, h: 60 };
                    dragRef.current = {
                        mode: 'draggingShape',
                        sx: e.clientX, sy: e.clientY,
                        shapeX: shape.x || 0, shapeY: shape.y || 0,
                        shapeCX: shape.cx || 0, shapeCY: shape.cy || 0,
                        initialPoints: shape.points ? JSON.parse(JSON.stringify(shape.points)) : null
                    };
                    setCursorMode('draggingShape');
                    return;
                }

                // ÈÅ∏ÊäûËß£Èô§
                setSelectedShapeIndex(null);
                setSelectedPointIndex(null);
            };

            const handleMove = (e) => {
                const mode = dragRef.current.mode;
                if (mode === 'idle') return;
                e.preventDefault();

                if (mode === 'panning') {
                    const dx = e.clientX - dragRef.current.sx;
                    const dy = e.clientY - dragRef.current.sy;
                    setViewState(p => ({ ...p, x: dragRef.current.vx + dx, y: dragRef.current.vy + dy }));
                } else if (mode === 'resizing' && selectedShapeIndex !== null) {
                    const dx = (e.clientX - dragRef.current.sx) / viewState.scale / BASE_SCALE;
                    const dy = (e.clientY - dragRef.current.sy) / viewState.scale / BASE_SCALE;
                    const newShapes = [...asset.shapes];
                    const targetShape = newShapes[selectedShapeIndex];
                    const resizeMode = dragRef.current.resizeMode;

                    if (resizeMode === 'both') {
                        const aspect = dragRef.current.shapeW / dragRef.current.shapeH;
                        const newW = Math.max(10, Math.round((dragRef.current.shapeW + dx) / SNAP_UNIT) * SNAP_UNIT);
                        const newH = Math.round(newW / aspect / SNAP_UNIT) * SNAP_UNIT;
                        targetShape.w = newW;
                        targetShape.h = newH;
                    } else if (resizeMode === 'horizontal') {
                        targetShape.w = Math.max(10, Math.round((dragRef.current.shapeW + dx) / SNAP_UNIT) * SNAP_UNIT);
                    } else if (resizeMode === 'vertical') {
                        targetShape.h = Math.max(10, Math.round((dragRef.current.shapeH + dy) / SNAP_UNIT) * SNAP_UNIT);
                    }
                    updateAssetShapes(newShapes);
                } else if (mode === 'draggingShape' && selectedShapeIndex !== null) {
                    const dx = (e.clientX - dragRef.current.sx) / viewState.scale / BASE_SCALE;
                    const dy = (e.clientY - dragRef.current.sy) / viewState.scale / BASE_SCALE;
                    const sdx = Math.round(dx / SNAP_UNIT) * SNAP_UNIT;
                    const sdy = Math.round(dy / SNAP_UNIT) * SNAP_UNIT;

                    const newShapes = [...asset.shapes];
                    const targetShape = newShapes[selectedShapeIndex];
                    if (targetShape.type === 'polygon' && dragRef.current.initialPoints) {
                        targetShape.points = dragRef.current.initialPoints.map(p => ({
                            ...p,
                            x: p.x + sdx,
                            y: p.y + sdy
                        }));
                    } else if (targetShape.type === 'ellipse') {
                        targetShape.cx = (dragRef.current.shapeCX || 0) + sdx;
                        targetShape.cy = (dragRef.current.shapeCY || 0) + sdy;
                    } else {
                        targetShape.x = dragRef.current.shapeX + sdx;
                        targetShape.y = dragRef.current.shapeY + sdy;
                    }
                    updateAssetShapes(newShapes);
                } else if (mode === 'draggingPoint' && selectedShapeIndex !== null && selectedPointIndex !== null) {
                    const dx = (e.clientX - dragRef.current.sx) / viewState.scale / BASE_SCALE;
                    const dy = (e.clientY - dragRef.current.sy) / viewState.scale / BASE_SCALE;
                    const newX = Math.round((dragRef.current.pointX + dx) / SNAP_UNIT) * SNAP_UNIT;
                    const newY = Math.round((dragRef.current.pointY + dy) / SNAP_UNIT) * SNAP_UNIT;

                    const newShapes = [...asset.shapes];
                    const pts = newShapes[selectedShapeIndex].points;
                    pts[selectedPointIndex] = { ...pts[selectedPointIndex], x: newX, y: newY };
                    updateAssetShapes(newShapes);
                } else if (mode === 'draggingHandle' && selectedShapeIndex !== null && selectedPointIndex !== null) {
                    const dx = (e.clientX - dragRef.current.sx) / viewState.scale / BASE_SCALE;
                    const dy = (e.clientY - dragRef.current.sy) / viewState.scale / BASE_SCALE;
                    const newX = Math.round((dragRef.current.handleX + dx) / SNAP_UNIT) * SNAP_UNIT;
                    const newY = Math.round((dragRef.current.handleY + dy) / SNAP_UNIT) * SNAP_UNIT;

                    const newShapes = [...asset.shapes];
                    const handles = [...newShapes[selectedShapeIndex].points[selectedPointIndex].handles];
                    handles[dragRef.current.handleIndex] = { x: newX, y: newY };
                    newShapes[selectedShapeIndex].points[selectedPointIndex] = {
                        ...newShapes[selectedShapeIndex].points[selectedPointIndex],
                        handles
                    };
                    updateAssetShapes(newShapes);
                } else if (mode === 'draggingAngle' && selectedShapeIndex !== null) {
                    // „Éû„Ç¶„Çπ‰ΩçÁΩÆ„Åã„ÇâËßíÂ∫¶„ÇíË®àÁÆó
                    const rect = dragRef.current.rect;
                    const mx = (e.clientX - rect.left - viewState.x) / viewState.scale / BASE_SCALE;
                    const my = (e.clientY - rect.top - viewState.y) / viewState.scale / BASE_SCALE;
                    const cx = dragRef.current.shapeCX;
                    const cy = dragRef.current.shapeCY;

                    // ‰∏≠ÂøÉ„Åã„Çâ„Éû„Ç¶„Çπ„Å∏„ÅÆËßíÂ∫¶ÔºàÂ∫¶Ôºâ
                    let angle = Math.atan2(my - cy, mx - cx) * 180 / Math.PI;
                    // 5Â∫¶Âàª„Åø„Å´„Çπ„Éä„ÉÉ„Éó
                    angle = Math.round(angle / 5) * 5;

                    const newShapes = [...asset.shapes];
                    const targetShape = newShapes[selectedShapeIndex];
                    if (dragRef.current.angleType === 'startAngle') {
                        targetShape.startAngle = angle;
                    } else {
                        targetShape.endAngle = angle;
                    }
                    updateAssetShapes(newShapes);
                } else if (mode === 'draggingRotation' && selectedShapeIndex !== null) {
                    // „Éû„Ç¶„Çπ‰ΩçÁΩÆ„Åã„ÇâÂõûËª¢ËßíÂ∫¶„ÇíË®àÁÆó
                    const rect = dragRef.current.rect;
                    const mx = (e.clientX - rect.left - viewState.x) / viewState.scale / BASE_SCALE;
                    const my = (e.clientY - rect.top - viewState.y) / viewState.scale / BASE_SCALE;
                    const cx = dragRef.current.shapeCX;
                    const cy = dragRef.current.shapeCY;

                    // ‰∏≠ÂøÉ„Åã„Çâ„Éû„Ç¶„Çπ„Å∏„ÅÆËßíÂ∫¶ - ‰∏äÂêë„Åç„Åå0Â∫¶„Å´„Å™„Çã„Çà„ÅÜ„Å´Ë™øÊï¥
                    let angle = Math.atan2(mx - cx, cy - my) * 180 / Math.PI;
                    // 5Â∫¶Âàª„Åø„Å´„Çπ„Éä„ÉÉ„Éó
                    angle = Math.round(angle / 5) * 5;

                    const newShapes = [...asset.shapes];
                    newShapes[selectedShapeIndex].rotation = angle;
                    updateAssetShapes(newShapes);
                } else if (mode === 'draggingRadius' && selectedShapeIndex !== null) {
                    // „Éû„Ç¶„Çπ‰ΩçÁΩÆ„Åã„ÇâÂçäÂæÑ„ÇíË®àÁÆó
                    const rect = dragRef.current.rect;
                    const mx = (e.clientX - rect.left - viewState.x) / viewState.scale / BASE_SCALE;
                    const my = (e.clientY - rect.top - viewState.y) / viewState.scale / BASE_SCALE;
                    const cx = dragRef.current.shapeCX;
                    const cy = dragRef.current.shapeCY;

                    const newShapes = [...asset.shapes];
                    const targetShape = newShapes[selectedShapeIndex];
                    if (dragRef.current.radiusType === 'rx') {
                        // Ê®™ÂçäÂæÑÔºö‰∏≠ÂøÉ„Åã„Çâ„ÅÆXË∑ùÈõ¢
                        const newRx = Math.max(10, Math.round(Math.abs(mx - cx) / SNAP_UNIT) * SNAP_UNIT);
                        targetShape.rx = newRx;
                    } else {
                        // Á∏¶ÂçäÂæÑÔºö‰∏≠ÂøÉ„Åã„Çâ„ÅÆYË∑ùÈõ¢
                        const newRy = Math.max(10, Math.round(Math.abs(my - cy) / SNAP_UNIT) * SNAP_UNIT);
                        targetShape.ry = newRy;
                    }
                    updateAssetShapes(newShapes);
                }
            };
            const handleUp = () => {
                dragRef.current.mode = 'idle';
                setCursorMode('idle');
            };

            const handleDeleteShape = (e, i) => {
                e.stopPropagation();
                if (!confirm('„Åì„ÅÆ„Ç∑„Çß„Ç§„Éó„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) return;
                const newShapes = asset.shapes.filter((_, idx) => idx !== i);
                setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                setSelectedShapeIndex(null);
            };
            const updateAssetShapes = (newShapes) => {
                let maxX = 0, maxY = 0;
                newShapes.forEach(s => {
                    if (s.points) s.points.forEach(p => { maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); });
                    else { maxX = Math.max(maxX, (s.x || 0) + s.w); maxY = Math.max(maxY, (s.y || 0) + s.h); }
                });
                setLocalAssets(prev => prev.map(a => a.id === designTargetId ? { ...a, shapes: newShapes, w: maxX, h: maxY } : a));
            };
            const shapes = (asset && asset.shapes && asset.shapes.length > 0)
                ? asset.shapes
                : (asset ? [{ type: asset.shape || 'rect', w: asset.w, h: asset.h, x: 0, y: 0, color: asset.color, points: asset.points || createRectPath(asset.w, asset.h) }] : []);

            return <DesignCanvasRender viewState={viewState} asset={asset} shapes={shapes} selectedShapeIndex={selectedShapeIndex} selectedPointIndex={selectedPointIndex} onDown={handleDown} onMove={handleMove} onUp={handleUp} onDeleteShape={handleDeleteShape} svgRef={svgRef} />;
        };

        const LayoutCanvas = ({ viewState, setViewState, assets, instances, setInstances, selectedIds, setSelectedIds }) => {
            const dragRef = useRef({ isDragging: false, mode: null });
            const svgRef = useRef(null);

            const handleDown = (e, id) => {
                // Â∑¶„ÇØ„É™„ÉÉ„ÇØ‰ª•Â§ñ„ÅØÁÑ°Ë¶ñÔºà‰∏≠„ÇØ„É™„ÉÉ„ÇØ„ÅØ‰æãÂ§ñ„Åß„Éë„É≥Áî®Ôºâ
                if (e.button !== 0 && e.button !== 1) return;

                // „Éù„Ç§„É≥„Çø„Éº„Ç≠„É£„Éó„ÉÅ„É£„ÇíË®≠ÂÆöÔºàÂøÖ„ÅöË¶™div„ÅßÊçïÊçâÔºâ
                if (svgRef.current && e.pointerId) {
                    try { svgRef.current.setPointerCapture(e.pointerId); } catch (err) { /* ignore */ }
                }

                const isPan = e.button === 1 || (id === null && e.button === 0);

                let targetIds = [];
                if (id) {
                    if (selectedIds.includes(id)) {
                        targetIds = [...selectedIds];
                    } else {
                        targetIds = [id];
                        setSelectedIds([id]);
                    }
                } else {
                    // ËÉåÊôØ„ÇØ„É™„ÉÉ„ÇØÊôÇ„ÅØÈÅ∏Êäû„ÇíËß£Èô§
                    setSelectedIds([]);
                }

                dragRef.current = {
                    isDragging: true,
                    mode: isPan ? 'panning' : (id ? 'dragging' : null),
                    sx: e.clientX, sy: e.clientY,
                    vx: viewState.x, vy: viewState.y,
                    items: instances.map(i => ({ ...i })),
                    targetIds: targetIds
                };

                if (!isPan && id) {
                    // „Ç¢„Ç§„ÉÜ„É†„Éâ„É©„ÉÉ„Ç∞ - „É≠„ÉÉ„ÇØÁä∂ÊÖã„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                    const hasUnlocked = targetIds.some(tid => {
                        const t = instances.find(i => i.id === tid);
                        return t && !t.locked;
                    });
                    if (!hasUnlocked) {
                        dragRef.current.isDragging = false;
                        dragRef.current.mode = null;
                    }
                }

                // „Ç¢„Ç§„ÉÜ„É†‰∏ä„Åß„ÅÆ„Ç§„Éô„É≥„Éà„ÅØËÉåÊôØ„Å´‰ºùÊí≠„Åï„Åõ„Å™„ÅÑ
                if (id) {
                    e.stopPropagation();
                }
                e.preventDefault();
            };
            const handleMove = (e) => {
                if (!dragRef.current.isDragging) return;
                e.preventDefault();
                const dx = e.clientX - dragRef.current.sx;
                const dy = e.clientY - dragRef.current.sy;
                if (dragRef.current.mode === 'panning') {
                    setViewState(p => ({ ...p, x: dragRef.current.vx + dx, y: dragRef.current.vy + dy }));
                } else if (dragRef.current.mode === 'dragging') {
                    const wDx = dx / viewState.scale / BASE_SCALE;
                    const wDy = dy / viewState.scale / BASE_SCALE;

                    setInstances(prev => prev.map(inst => {
                        if (dragRef.current.targetIds?.includes(inst.id) && !inst.locked) {
                            const org = dragRef.current.items.find(i => i.id === inst.id);
                            if (!org) return inst;
                            const asset = assets.find(a => a.id === inst.assetId);
                            let nx = org.x + wDx;
                            let ny = org.y + wDy;
                            if (inst.type !== 'text' && asset?.snap && inst.rotation % 90 === 0) {
                                nx = Math.round(nx / SNAP_UNIT) * SNAP_UNIT;
                                ny = Math.round(ny / SNAP_UNIT) * SNAP_UNIT;
                            }
                            return { ...inst, x: nx, y: ny };
                        }
                        return inst;
                    }));
                }
            };
            const handleUp = () => { dragRef.current = { isDragging: false, mode: null, targetIds: [] }; };

            const sortedItems = useMemo(() => {
                return instances.map(inst => {
                    if (inst.type === 'text') return { ...inst, z: 99 };
                    const asset = assets.find(a => a.id === inst.assetId);
                    // id „ÅØ inst.id „ÇíÁ∂≠ÊåÅÔºàasset.id „Åß‰∏äÊõ∏„Åç„Åï„Çå„Å™„ÅÑ„Çà„ÅÜÊòéÁ§∫ÁöÑ„Å´ÊåáÂÆöÔºâ
                    return asset ? { ...inst, ...asset, id: inst.id, z: LAYERS[asset.type] } : null;
                }).filter(Boolean).sort((a, b) => {
                    // ÈÅ∏Êäû„Ç¢„Ç§„ÉÜ„É†„ÇíÊúÄÂâçÈù¢„Å´
                    const aSelected = selectedIds.includes(a.id) ? 1000 : 0;
                    const bSelected = selectedIds.includes(b.id) ? 1000 : 0;
                    return (a.z + aSelected) - (b.z + bSelected);
                });
            }, [instances, assets, selectedIds]);

            return (
                <div className="w-full h-full absolute top-0 left-0 z-20 overflow-auto canvas-scroll pt-5 pl-5" onPointerDown={e => handleDown(e, null)} onPointerMove={handleMove} onPointerUp={handleUp} ref={svgRef}>
                    <svg width="3000" height="3000" style={{ minWidth: '3000px', minHeight: '3000px' }}>
                        <g transform={`translate(${viewState.x}, ${viewState.y}) scale(${viewState.scale})`}>
                            <line x1="-5000" y1="0" x2="5000" y2="0" stroke="#ddd" strokeWidth="2" />
                            <line x1="0" y1="-5000" x2="0" y2="5000" stroke="#ddd" strokeWidth="2" />
                            {sortedItems.map(item => <RenderItem key={item.id} item={item} isSelected={selectedIds.includes(item.id)} onDown={handleDown} />)}
                        </g>
                    </svg>
                </div>
            );
        };

        // --- Sidebars & Properties Panels ---

        const UnifiedSidebar = ({ mode, assets, onAddInstance, onAddText, setLocalAssets, setGlobalAssets, setDesignTargetId, designTargetId, instances, setInstances }) => {
            // Â∏∏„Å´„É≠„Éº„Ç´„É´„Ç¢„Çª„ÉÉ„Éà„ÅÆ„ÅøË°®Á§∫Ôºàglobal„ÅØ„Éó„É≠„Ç∏„Çß„ÇØ„ÉàË™≠ËæºÊôÇ„Å´Ëá™Âãï„Éï„Ç©„Éº„ÇØÊ∏à„ÅøÔºâ
            const filteredAssets = assets.filter(a => !a.source || a.source !== 'global');

            // Êñ∞Ë¶è‰ΩúÊàê (Design ModeÁî®)
            const addNewAsset = () => {
                const initialShape = {
                    type: 'polygon',
                    points: createRectPath(60, 60, 0, 0),
                    color: '#cccccc'
                };
                const newA = {
                    id: `a-${Date.now()}`, name: 'Êñ∞Ë¶è„Éë„Éº„ÉÑ', type: 'room',
                    w: 60, h: 60, color: '#cccccc', snap: true,
                    shapes: [initialShape]
                };
                setLocalAssets(prev => [...prev, newA]);
                setDesignTargetId(newA.id);
            };

            const handleClick = (asset) => {
                if (mode === 'layout') {
                    onAddInstance(asset.id);
                } else {
                    setDesignTargetId(asset.id);
                }
            };

            const deleteAsset = (e, assetId, isGlobal) => {
                e.stopPropagation();
                const usageCount = instances.filter(inst => inst.assetId === assetId).length;
                const message = usageCount > 0
                    ? `„Åì„ÅÆ„Ç¢„Çª„ÉÉ„Éà„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü\nÈÖçÁΩÆÊ∏à„Åø: ${usageCount}ÂÄã„ÅåÂâäÈô§„Åï„Çå„Åæ„Åô„ÄÇ`
                    : '„Åì„ÅÆ„Ç¢„Çª„ÉÉ„Éà„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü';
                if (!confirm(message)) return;

                if (isGlobal) {
                    setGlobalAssets(prev => prev.filter(a => a.id !== assetId));
                } else {
                    setLocalAssets(prev => prev.filter(a => a.id !== assetId));
                }
                setInstances(prev => prev.filter(inst => inst.assetId !== assetId));
                if (designTargetId === assetId) {
                    setDesignTargetId(null);
                }
            };

            return (
                <div className="flex flex-col h-full bg-white">
                    {/* Header Action Area */}
                    <div className="p-3 pb-0">
                        {mode === 'layout' ? (
                            <button onClick={onAddText} className="w-full py-2 bg-yellow-50 border border-yellow-200 text-yellow-800 rounded font-bold mb-2 flex items-center justify-center gap-2 hover:bg-yellow-100 transition text-xs"><Icon p={Icons.Type} /> ÊñáÂ≠ó„ÇíËøΩÂä†</button>
                        ) : (
                            <button onClick={addNewAsset} className="w-full py-2 bg-white border border-dashed border-orange-300 rounded text-orange-600 hover:bg-orange-50 font-bold text-xs">+ Êñ∞Ë¶è„Éë„Éº„ÉÑ</button>
                        )}
                    </div>

                    {/* Asset List (Grid) */}
                    <div className="flex-1 overflow-y-auto p-3">
                        {['room', 'fixture', 'furniture'].map(type => {
                            const typeAssets = filteredAssets.filter(a => a.type === type);
                            if (typeAssets.length === 0) return null;
                            const label = type === 'room' ? 'ÈÉ®Â±ã' : type === 'fixture' ? 'Ë®≠ÂÇô' : 'ÂÆ∂ÂÖ∑';
                            return (
                                <div key={type} className="mb-6">
                                    <div className="text-xs font-bold text-gray-400 mb-2 px-1 border-b pb-1 flex items-center gap-2">{label}</div>
                                    <div className="grid grid-cols-2 gap-2">
                                        {typeAssets.map(a => {
                                            const isSelected = mode === 'design' && designTargetId === a.id;
                                            return (
                                                <button key={a.id} onClick={() => handleClick(a)}
                                                    className={`flex flex-col items-center p-2 border rounded hover:bg-gray-50 text-center relative group transition
                                                        ${a.source === 'global' ? 'bg-blue-50/30 border-blue-100' : ''}
                                                        ${isSelected ? 'ring-2 ring-orange-400 bg-orange-50' : ''}
                                                    `}>
                                                    {a.source === 'global' && <div className="absolute top-1 right-1 text-blue-400"><Icon p={Icons.Globe} size={10} /></div>}
                                                    <div className="w-8 h-8 rounded mb-2 border shadow-sm flex items-center justify-center" style={{ backgroundColor: a.color }}></div>
                                                    <span className="text-[10px] w-full truncate font-medium text-gray-600">{a.name}</span>

                                                    {/* Delete Button (Only visible in Design Mode or for cleanup) */}
                                                    {mode === 'design' && (
                                                        <div
                                                            onClick={(e) => deleteAsset(e, a.id, a.source === 'global')}
                                                            className="absolute top-1 left-1 opacity-0 group-hover:opacity-100 text-gray-300 hover:text-red-500 p-1 transition"
                                                        >
                                                            <Icon p={Icons.Trash} size={12} />
                                                        </div>
                                                    )}
                                                </button>
                                            );
                                        })}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        const LayoutProperties = ({ instances, setInstances, selectedIds, assets, setSelectedIds, setMode, setDesignTargetId }) => {
            const item = instances.find(i => i.id === selectedIds[0]);

            // Êú™ÈÅ∏ÊäûÊôÇ„ÅØÁ∞°Êòì„É™„Çπ„ÉàË°®Á§∫
            if (!item) {
                return (
                    <div className="h-full flex flex-col text-gray-500 text-xs items-center justify-center p-4">
                        <Icon p={Icons.Move} size={48} className="text-gray-200 mb-2" />
                        <p>„Ç≠„É£„É≥„Éê„Çπ‰∏ä„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÇíÈÅ∏Êäû„Åô„Çã„Å®<br />Ë©≥Á¥∞Ë®≠ÂÆö„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô</p>
                        <div className="mt-8 w-full border-t pt-4">
                            <p className="font-bold text-gray-400 mb-2 text-left w-full">ÈÖçÁΩÆÊ∏à„Åø ({instances.length})</p>
                            <div className="space-y-1 max-h-60 overflow-y-auto w-full text-left">
                                {instances.map(inst => {
                                    const a = assets.find(x => x.id === inst.assetId);
                                    return (
                                        <div key={inst.id} onClick={() => setSelectedIds([inst.id])} className="p-2 border rounded hover:bg-gray-50 cursor-pointer flex items-center justify-between">
                                            <span className="truncate">{a ? a.name : inst.text}</span>
                                            <span className="text-[10px] text-gray-300">{inst.id.slice(-4)}</span>
                                        </div>
                                    )
                                })}
                            </div>
                        </div>
                    </div>
                );
            }

            const update = (k, v) => setInstances(p => p.map(i => i.id === item.id ? { ...i, [k]: v } : i));

            // „Ç∞„É´„Éº„ÉóÊï¥ÂàóÊ©üËÉΩ
            const alignToOrigin = () => {
                const targets = instances.filter(i => selectedIds.includes(i.id));
                if (targets.length === 0) return;
                const minX = Math.min(...targets.map(i => i.x));
                const minY = Math.min(...targets.map(i => i.y));
                setInstances(prev => prev.map(i => {
                    if (selectedIds.includes(i.id)) {
                        return { ...i, x: i.x - minX, y: i.y - minY };
                    }
                    return i;
                }));
            };

            const asset = assets.find(a => a.id === item.assetId);

            return (
                <div className="h-full flex flex-col">
                    <div className="sidebar-header">
                        <span>ÈÖçÁΩÆ„Éó„É≠„Éë„ÉÜ„Ç£</span>
                        <button onClick={alignToOrigin} className="text-[10px] bg-blue-50 text-blue-600 px-2 py-1 rounded border border-blue-200 hover:bg-blue-100">
                            0,0„Å∏ÁßªÂãï
                        </button>
                    </div>

                    <div className="p-3 overflow-y-auto flex-1">
                        {/* Selected Item Info */}
                        <div className="bg-blue-50 border border-blue-100 rounded p-3 mb-4">
                            <div className="font-bold text-sm text-blue-800 mb-1">{item.type === 'text' ? '„ÉÜ„Ç≠„Çπ„Éà' : asset?.name}</div>
                            <div className="text-[10px] text-blue-400 font-mono">{item.id}</div>
                        </div>

                        {/* Actions */}
                        {item.type !== 'text' && (
                            <button
                                onClick={() => {
                                    setDesignTargetId(item.assetId);
                                    setMode('design');
                                }}
                                className="btn-action bg-orange-500 text-white hover:bg-orange-600 mb-4 shadow-sm"
                            >
                                <Icon p={Icons.Pen} size={14} /> ÂΩ¢Áä∂„ÇíÁ∑®ÈõÜ (Ë®≠Ë®à„É¢„Éº„Éâ)
                            </button>
                        )}

                        {/* Coordinates */}
                        <div className="mb-4">
                            <div className="text-xs font-bold text-gray-400 mb-2 border-b pb-1">Â∫ßÊ®ô„ÉªÂõûËª¢</div>
                            <div className="prop-row">
                                <label className="prop-label">X (mm)</label>
                                <input type="number" value={toMM(item.x)} onChange={e => update('x', fromMM(Number(e.target.value)))} className="prop-input" />
                            </div>
                            <div className="prop-row">
                                <label className="prop-label">Y (mm)</label>
                                <input type="number" value={toMM(item.y)} onChange={e => update('y', fromMM(Number(e.target.value)))} className="prop-input" />
                            </div>
                            <div className="prop-row">
                                <label className="prop-label">ÂõûËª¢ (¬∞)</label>
                                <div className="flex-1 flex gap-2">
                                    <input type="number" value={item.rotation} onChange={e => update('rotation', Number(e.target.value))} className="prop-input" />
                                    <button onClick={() => update('rotation', (item.rotation + 90) % 360)} className="px-2 border rounded bg-gray-50 hover:bg-gray-100 text-xs">‚Üª</button>
                                </div>
                            </div>
                        </div>

                        {/* Content (Text only) */}
                        {item.type === 'text' && (
                            <div className="mb-4">
                                <div className="text-xs font-bold text-gray-400 mb-2 border-b pb-1">„ÉÜ„Ç≠„Çπ„ÉàË®≠ÂÆö</div>
                                <div className="mb-2">
                                    <label className="prop-label block text-left mb-1">ÂÜÖÂÆπ</label>
                                    <textarea value={item.text} onChange={e => update('text', e.target.value)} className="w-full border rounded p-2 text-sm h-20" />
                                </div>
                                <div className="prop-row">
                                    <label className="prop-label">„Çµ„Ç§„Ç∫</label>
                                    <input type="number" value={item.fontSize} onChange={e => update('fontSize', Number(e.target.value))} className="prop-input" />
                                </div>
                                <div className="prop-row">
                                    <label className="prop-label">Ëâ≤</label>
                                    <input type="color" value={item.color} onChange={e => update('color', e.target.value)} className="h-8 w-full cursor-pointer" />
                                </div>
                            </div>
                        )}

                        {/* Copy / Lock / Delete */}
                        <div className="border-t pt-4 mt-2 space-y-2">
                            <button onClick={() => {
                                const newInst = { ...item, id: `${item.type === 'text' ? 't' : 'i'}-${Date.now()}`, x: item.x + 10, y: item.y + 10 };
                                setInstances(p => [...p, newInst]);
                                setSelectedIds([newInst.id]);
                            }} className="btn-action bg-blue-50 border border-blue-200 text-blue-600 hover:bg-blue-100">
                                <Icon p={Icons.Copy} size={14} /> „Ç≥„Éî„Éº„Åó„Å¶ÈÖçÁΩÆ
                            </button>
                            <label className="flex items-center gap-2 p-2 rounded cursor-pointer hover:bg-gray-50 border">
                                <input type="checkbox" checked={item.locked} onChange={e => update('locked', e.target.checked)} className="accent-blue-600" />
                                <span className="text-xs font-bold text-gray-600 flex items-center gap-1">
                                    {item.locked ? <Icon p={Icons.Lock} size={12} /> : <Icon p={Icons.Unlock} size={12} />} „É≠„ÉÉ„ÇØ„Åô„Çã
                                </span>
                            </label>
                            <button onClick={() => { setInstances(p => p.filter(i => i.id !== item.id)); setSelectedIds([]); }} className="btn-action bg-white border border-red-200 text-red-500 hover:bg-red-50">
                                <Icon p={Icons.Trash} size={14} /> ÂâäÈô§
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const DesignProperties = ({ assets, designTargetId, setLocalAssets, setGlobalAssets, selectedShapeIndex, setSelectedShapeIndex, selectedPointIndex, setSelectedPointIndex, setDesignTargetId, palette, onAddToPalette }) => {
            const asset = assets.find(a => a.id === designTargetId);

            // Êú™ÈÅ∏ÊäûÊôÇ
            if (!asset) {
                return (
                    <div className="h-full flex flex-col text-gray-500 text-xs items-center justify-center p-4">
                        <Icon p={Icons.Pen} size={48} className="text-orange-200 mb-2" />
                        <p>Â∑¶„ÅÆ„É™„Çπ„Éà„Åã„ÇâÁ∑®ÈõÜ„Åô„Çã<br />„Ç¢„Çª„ÉÉ„Éà„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>
                    </div>
                );
            }

            const updateRoot = (k, v) => { if (asset.source === 'global') return; setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, [k]: v } : a)); };
            const updateShape = (k, v) => {
                if (asset.source === 'global' || selectedShapeIndex === null) return;
                const currentShapes = asset.shapes || [];
                const newShapes = currentShapes.map((s, i) => i === selectedShapeIndex ? { ...s, [k]: v } : s);
                setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
            };
            const updatePoint = (k, v) => {
                if (asset.source === 'global' || selectedShapeIndex === null || selectedPointIndex === null) return;
                const newShapes = [...asset.shapes];
                const newPts = [...newShapes[selectedShapeIndex].points];
                const newPt = { ...newPts[selectedPointIndex], [k]: v };
                newPts[selectedPointIndex] = newPt;
                newShapes[selectedShapeIndex].points = newPts;
                setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
            };

            const fork = () => {
                const newId = `a-fork-${Date.now()}`;
                const newA = { ...asset, id: newId, name: asset.name + ' („Ç≥„Éî„Éº)', source: undefined };
                setLocalAssets(prev => [...prev, newA]);
                if (setDesignTargetId) setDesignTargetId(newId);
            };
            const publish = () => { if (!confirm('ÂÖ±ÈÄö„É©„Ç§„Éñ„É©„É™„Å´ËøΩÂä†„Åó„Åæ„Åô„ÅãÔºü')) return; setGlobalAssets(prev => [...prev, { ...asset, id: `a-pub-${Date.now()}`, source: undefined }]); alert('ËøΩÂä†„Åó„Åæ„Åó„Åü'); };

            // ÂÖ®‰Ωì„Çí(0,0)„Å´ÂØÑ„Åõ„Çã
            const normalizePosition = () => {
                if (asset.source === 'global') return;
                const shapes = asset.shapes || [];
                if (shapes.length === 0) return;
                let minX = Infinity, minY = Infinity;
                shapes.forEach(s => {
                    if (s.points) {
                        s.points.forEach(p => { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); });
                    } else {
                        minX = Math.min(minX, s.x || 0); minY = Math.min(minY, s.y || 0);
                    }
                });
                if (minX === Infinity || (minX === 0 && minY === 0)) return;
                const newShapes = shapes.map(s => {
                    if (s.points) return { ...s, points: s.points.map(p => ({ ...p, x: p.x - minX, y: p.y - minY })) };
                    return { ...s, x: (s.x || 0) - minX, y: (s.y || 0) - minY };
                });
                let maxX = 0, maxY = 0;
                newShapes.forEach(s => {
                    if (s.points) s.points.forEach(p => { maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); });
                    else { maxX = Math.max(maxX, (s.x || 0) + s.w); maxY = Math.max(maxY, (s.y || 0) + s.h); }
                });
                setLocalAssets(prev => prev.map(a => a.id === designTargetId ? { ...a, shapes: newShapes, w: maxX, h: maxY } : a));
            };

            if (asset.source === 'global') return (
                <div className="p-4 bg-blue-50 h-full flex flex-col items-center justify-center text-center">
                    <Icon p={Icons.Lock} size={32} className="text-blue-300 mb-2" />
                    <div className="text-sm font-bold text-blue-800 mb-1">{asset.name}</div>
                    <div className="text-xs text-blue-600 mb-4">ÂÖ±ÈÄö„Éë„Éº„ÉÑ„ÅØÁ∑®ÈõÜ„Åß„Åç„Åæ„Åõ„Çì</div>
                    <button onClick={fork} className="bg-blue-600 text-white text-xs px-4 py-2 rounded shadow hover:bg-blue-700 flex items-center gap-2"><Icon p={Icons.Copy} size={14} /> „Ç≥„Éî„Éº„Åó„Å¶Á∑®ÈõÜ</button>
                </div>
            );

            const selectedShape = (asset.shapes && selectedShapeIndex !== null) ? asset.shapes[selectedShapeIndex] : null;
            const selectedPoint = (selectedShape && selectedShape.points && selectedPointIndex !== null) ? selectedShape.points[selectedPointIndex] : null;

            return (
                <div className="h-full flex flex-col">
                    <div className="sidebar-header">
                        <span>ÂΩ¢Áä∂„Éó„É≠„Éë„ÉÜ„Ç£</span>
                        <button onClick={normalizePosition} className="text-[10px] bg-orange-50 text-orange-600 px-2 py-1 rounded border border-orange-200 hover:bg-orange-100">
                            0,0„Å´ÊèÉ„Åà„Çã
                        </button>
                    </div>

                    <div className="p-3 overflow-y-auto flex-1 space-y-4">
                        {/* Basic Info */}
                        <div className="bg-orange-50 border border-orange-100 rounded p-2">
                            <div className="prop-row">
                                <label className="prop-label">ÂêçÁß∞</label>
                                <input value={asset.name} onChange={e => updateRoot('name', e.target.value)} className="prop-input font-bold text-left" />
                            </div>
                            <div className="prop-row">
                                <label className="prop-label">Á®ÆÈ°û</label>
                                <select value={asset.type} onChange={e => updateRoot('type', e.target.value)} className="prop-input text-xs">
                                    <option value="room">ÈÉ®Â±ã„ÉªÂ∫ä</option>
                                    <option value="fixture">Ë®≠ÂÇô„ÉªÂª∫ÂÖ∑</option>
                                    <option value="furniture">ÂÆ∂ÂÖ∑</option>
                                </select>
                            </div>
                            <div className="pt-2">
                                <label className="prop-label block mb-1">ÂÖ®‰ΩìËâ≤</label>
                                <ColorPicker value={asset.color} onChange={c => updateRoot('color', c)} palette={palette} onAddToPalette={onAddToPalette} />
                            </div>
                        </div>

                        {/* Shape / Point Editor */}
                        {selectedPoint ? (
                            <div className="bg-white p-2 rounded border-2 border-red-300">
                                <div className="text-xs font-bold text-red-600 mb-2">ÈÅ∏ÊäûÈ†ÇÁÇπ (mm)</div>
                                <div className="prop-row">
                                    <label className="prop-label">X</label>
                                    <input type="number" value={toMM(selectedPoint.x)} onChange={e => updatePoint('x', fromMM(Number(e.target.value)))} className="prop-input" />
                                </div>
                                <div className="prop-row">
                                    <label className="prop-label">Y</label>
                                    <input type="number" value={toMM(selectedPoint.y)} onChange={e => updatePoint('y', fromMM(Number(e.target.value)))} className="prop-input" />
                                </div>
                                <div className="mt-2 pt-2 border-t">
                                    <button onClick={() => {
                                        if (selectedShape.points.length <= 3) { alert('ÊúÄ‰Ωé3ÁÇπÂøÖË¶Å„Åß„Åô'); return; }
                                        const newPts = selectedShape.points.filter((_, i) => i !== selectedPointIndex);
                                        const newShapes = [...asset.shapes];
                                        newShapes[selectedShapeIndex].points = newPts;
                                        setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                                        setSelectedPointIndex(null);
                                    }} className="w-full py-1.5 text-xs bg-red-50 border border-red-200 text-red-600 rounded hover:bg-red-100 font-bold">„Åì„ÅÆÈ†ÇÁÇπ„ÇíÂâäÈô§</button>
                                </div>
                            </div>
                        ) : selectedShape ? (
                            <div className="bg-white p-2 rounded border-2 border-blue-300">
                                <div className="text-xs font-bold text-blue-600 mb-2">ÈÅ∏Êäû„Éë„Éº„ÉÑ (mm)</div>
                                {selectedShape.type !== 'polygon' && selectedShape.type !== 'ellipse' && (
                                    <>
                                        <div className="prop-row"><label className="prop-label">ÂπÖ</label><input type="number" value={toMM(selectedShape.w)} onChange={e => updateShape('w', fromMM(Number(e.target.value)))} className="prop-input" /></div>
                                        <div className="prop-row"><label className="prop-label">Â••</label><input type="number" value={toMM(selectedShape.h)} onChange={e => updateShape('h', fromMM(Number(e.target.value)))} className="prop-input" /></div>
                                        <div className="prop-row"><label className="prop-label">X</label><input type="number" value={toMM(selectedShape.x || 0)} onChange={e => updateShape('x', fromMM(Number(e.target.value)))} className="prop-input" /></div>
                                        <div className="prop-row"><label className="prop-label">Y</label><input type="number" value={toMM(selectedShape.y || 0)} onChange={e => updateShape('y', fromMM(Number(e.target.value)))} className="prop-input" /></div>
                                    </>
                                )}
                                <div className="pt-2">
                                    <label className="prop-label block mb-1">Ëâ≤</label>
                                    <ColorPicker value={selectedShape.color || asset.color} onChange={c => updateShape('color', c)} palette={palette} onAddToPalette={onAddToPalette} />
                                </div>

                                {/* Ê•ïÂÜÜ„Éó„É≠„Éë„ÉÜ„Ç£ */}
                                {selectedShape.type === 'ellipse' && (
                                    <div className="mt-3 border-t pt-2">
                                        <div className="text-[10px] font-bold text-green-600 mb-2">Ê•ïÂÜÜ„Éó„É≠„Éë„ÉÜ„Ç£</div>
                                        <div className="prop-row"><label className="prop-label">‰∏≠ÂøÉX</label><input type="number" value={toMM(selectedShape.cx || 0)} onChange={e => updateShape('cx', fromMM(Number(e.target.value)))} className="prop-input" /></div>
                                        <div className="prop-row"><label className="prop-label">‰∏≠ÂøÉY</label><input type="number" value={toMM(selectedShape.cy || 0)} onChange={e => updateShape('cy', fromMM(Number(e.target.value)))} className="prop-input" /></div>
                                        <div className="prop-row"><label className="prop-label">Ê®™ÂçäÂæÑ</label><input type="number" value={toMM(selectedShape.rx || 50)} onChange={e => updateShape('rx', fromMM(Number(e.target.value)))} className="prop-input" /></div>
                                        <div className="prop-row"><label className="prop-label">Á∏¶ÂçäÂæÑ</label><input type="number" value={toMM(selectedShape.ry || 50)} onChange={e => updateShape('ry', fromMM(Number(e.target.value)))} className="prop-input" /></div>
                                        <div className="prop-row"><label className="prop-label">ÂõûËª¢¬∞</label><input type="number" value={selectedShape.rotation || 0} onChange={e => updateShape('rotation', Number(e.target.value))} className="prop-input" /></div>
                                        <div className="prop-row"><label className="prop-label">ÈñãÂßãËßí¬∞</label><input type="number" value={selectedShape.startAngle || 0} onChange={e => updateShape('startAngle', Number(e.target.value))} className="prop-input" /></div>
                                        <div className="prop-row"><label className="prop-label">ÁµÇ‰∫ÜËßí¬∞</label><input type="number" value={selectedShape.endAngle || 360} onChange={e => updateShape('endAngle', Number(e.target.value))} className="prop-input" /></div>
                                        <div className="prop-row items-center">
                                            <label className="prop-label">ÂΩ¢Áä∂</label>
                                            <select value={selectedShape.arcMode || 'sector'} onChange={e => updateShape('arcMode', e.target.value)} className="prop-input text-xs">
                                                <option value="sector">ÊâáÂΩ¢</option>
                                                <option value="chord">ÂºìÂΩ¢</option>
                                            </select>
                                        </div>
                                    </div>
                                )}
                                {selectedShape.type === 'polygon' && selectedShape.points && (
                                    <div className="mt-3 border-t pt-2">
                                        <div className="flex justify-between items-center mb-2">
                                            <span className="text-[10px] font-bold text-purple-600">È†ÇÁÇπÁ∑®ÈõÜ ({selectedShape.points.length}ÁÇπ)</span>
                                        </div>
                                        <div className="space-y-0 max-h-48 overflow-y-auto scrollbar-thin">
                                            {selectedShape.points.map((pt, idx) => (
                                                <React.Fragment key={idx}>
                                                    {/* È†ÇÁÇπË°å */}
                                                    <div className={`border rounded p-1.5 ${selectedPointIndex === idx ? 'bg-purple-50 border-purple-300' : 'hover:bg-gray-50'}`}>
                                                        <div className="flex items-center gap-1">
                                                            <span onClick={() => setSelectedPointIndex(idx)} className="w-5 h-5 flex items-center justify-center font-bold text-purple-400 bg-purple-100 rounded cursor-pointer text-[10px]">{idx}</span>
                                                            <input type="number" value={toMM(pt.x)} onChange={e => {
                                                                const newPts = [...selectedShape.points];
                                                                newPts[idx] = { ...newPts[idx], x: fromMM(Number(e.target.value)) };
                                                                const newShapes = [...asset.shapes];
                                                                newShapes[selectedShapeIndex].points = newPts;
                                                                setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                                                            }} className="flex-1 text-[10px] p-0.5 border rounded w-12 text-center" placeholder="X" />
                                                            <input type="number" value={toMM(pt.y)} onChange={e => {
                                                                const newPts = [...selectedShape.points];
                                                                newPts[idx] = { ...newPts[idx], y: fromMM(Number(e.target.value)) };
                                                                const newShapes = [...asset.shapes];
                                                                newShapes[selectedShapeIndex].points = newPts;
                                                                setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                                                            }} className="flex-1 text-[10px] p-0.5 border rounded w-12 text-center" placeholder="Y" />
                                                            <button onClick={() => {
                                                                if (selectedShape.points.length <= 3) { alert('ÊúÄ‰Ωé3ÁÇπÂøÖË¶Å„Åß„Åô'); return; }
                                                                const newPts = selectedShape.points.filter((_, i) => i !== idx);
                                                                const newShapes = [...asset.shapes];
                                                                newShapes[selectedShapeIndex].points = newPts;
                                                                setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                                                                if (selectedPointIndex === idx) setSelectedPointIndex(null);
                                                            }} className="text-[10px] text-red-400 hover:text-red-600 p-0.5" title="ÂâäÈô§">√ó</button>
                                                        </div>
                                                    </div>
                                                    {/* È†ÇÁÇπÈñì„ÅÆÊìç‰Ωú„Éú„Çø„É≥ */}
                                                    <div className="flex flex-col items-center py-1 gap-0.5 bg-gray-50 rounded my-0.5">
                                                        <div className="text-[8px] text-gray-400">Ëæ∫ {idx}‚Üí{(idx + 1) % selectedShape.points.length}</div>
                                                        <div className="flex gap-1">
                                                            <button onClick={() => {
                                                                const nextIdx = (idx + 1) % selectedShape.points.length;
                                                                const nextPt = selectedShape.points[nextIdx];
                                                                const newPt = { x: (pt.x + nextPt.x) / 2, y: (pt.y + nextPt.y) / 2, handles: [] };
                                                                const newPts = [...selectedShape.points.slice(0, idx + 1), newPt, ...selectedShape.points.slice(idx + 1)];
                                                                const newShapes = [...asset.shapes];
                                                                newShapes[selectedShapeIndex].points = newPts;
                                                                setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                                                            }} className="text-[9px] text-green-600 hover:bg-green-100 px-1.5 py-0.5 rounded border border-green-300" title="È†ÇÁÇπ„ÇíËøΩÂä†">
                                                                +È†ÇÁÇπ
                                                            </button>
                                                            {(!pt.handles || pt.handles.length < 2) && (
                                                                <button onClick={() => {
                                                                    const newPts = [...selectedShape.points];
                                                                    const handles = newPts[idx].handles || [];
                                                                    const nextIdx = (idx + 1) % selectedShape.points.length;
                                                                    const nextPt = selectedShape.points[nextIdx];
                                                                    // Êñ∞„Åó„ÅÑÂà∂Âæ°ÁÇπ„ÇíËæ∫„ÅÆ‰∏≠Èñì„Å´ËøΩÂä†
                                                                    const t = (handles.length + 1) / 3; // 1„Å§ÁõÆ„ÅØ1/3„ÄÅ2„Å§ÁõÆ„ÅØ2/3„ÅÆ‰ΩçÁΩÆ
                                                                    const midX = pt.x + (nextPt.x - pt.x) * t;
                                                                    const midY = pt.y + (nextPt.y - pt.y) * t - 15;
                                                                    newPts[idx] = { ...newPts[idx], handles: [...handles, { x: midX, y: midY }] };
                                                                    const newShapes = [...asset.shapes];
                                                                    newShapes[selectedShapeIndex].points = newPts;
                                                                    setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                                                                }} className="text-[9px] text-blue-600 hover:bg-blue-100 px-1.5 py-0.5 rounded border border-blue-300" title="Êõ≤Á∑öÂà∂Âæ°ÁÇπ„ÇíËøΩÂä†">
                                                                    +Êõ≤Á∑ö{pt.handles?.length === 1 ? '2' : ''}
                                                                </button>
                                                            )}
                                                            {(pt.handles?.length > 0) && (
                                                                <button onClick={() => {
                                                                    const newPts = [...selectedShape.points];
                                                                    const handles = [...(newPts[idx].handles || [])];
                                                                    handles.pop(); // ÊúÄÂæå„ÅÆÂà∂Âæ°ÁÇπ„ÇíÂâäÈô§
                                                                    newPts[idx] = { ...newPts[idx], handles };
                                                                    const newShapes = [...asset.shapes];
                                                                    newShapes[selectedShapeIndex].points = newPts;
                                                                    setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                                                                }} className="text-[9px] text-red-500 hover:bg-red-100 px-1 py-0.5 rounded border border-red-300" title="Âà∂Âæ°ÁÇπ„ÇíÂâäÈô§">
                                                                    -{pt.handles.length}Êõ≤
                                                                </button>
                                                            )}
                                                        </div>
                                                        {/* Âà∂Âæ°ÁÇπÂ∫ßÊ®ôÂÖ•Âäõ */}
                                                        {pt.handles && pt.handles.length > 0 && (
                                                            <div className="mt-1 space-y-0.5">
                                                                {pt.handles.map((h, hid) => (
                                                                    <div key={hid} className="flex items-center gap-1 bg-orange-50 rounded px-1 py-0.5">
                                                                        <span className="text-[8px] text-orange-500 font-bold w-4">C{hid + 1}</span>
                                                                        <input type="number" value={toMM(h.x)} onChange={e => {
                                                                            const newPts = [...selectedShape.points];
                                                                            const handles = [...newPts[idx].handles];
                                                                            handles[hid] = { ...handles[hid], x: fromMM(Number(e.target.value)) };
                                                                            newPts[idx] = { ...newPts[idx], handles };
                                                                            const newShapes = [...asset.shapes];
                                                                            newShapes[selectedShapeIndex].points = newPts;
                                                                            setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                                                                        }} className="flex-1 text-[9px] p-0.5 border rounded w-10 text-center" placeholder="X" />
                                                                        <input type="number" value={toMM(h.y)} onChange={e => {
                                                                            const newPts = [...selectedShape.points];
                                                                            const handles = [...newPts[idx].handles];
                                                                            handles[hid] = { ...handles[hid], y: fromMM(Number(e.target.value)) };
                                                                            newPts[idx] = { ...newPts[idx], handles };
                                                                            const newShapes = [...asset.shapes];
                                                                            newShapes[selectedShapeIndex].points = newPts;
                                                                            setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                                                                        }} className="flex-1 text-[9px] p-0.5 border rounded w-10 text-center" placeholder="Y" />
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        )}
                                                    </div>
                                                </React.Fragment>
                                            ))}
                                        </div>
                                    </div>
                                )}
                            </div>
                        ) : (
                            <div className="text-xs text-gray-400 p-2 text-center border rounded border-dashed">„Ç≠„É£„É≥„Éê„Çπ‰∏ä„ÅÆ„Éë„Éº„ÉÑ„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶Á∑®ÈõÜ</div>
                        )}

                        {/* Structure List */}
                        <div className="mt-4 border-t pt-2">
                            <div className="flex justify-between items-center mb-2">
                                <label className="text-xs font-bold text-gray-500">ÊßãÊàêË¶ÅÁ¥†</label>
                                <div className="flex gap-1">
                                    <button onClick={() => setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: [...(a.shapes || []), { type: 'polygon', points: createRectPath(40, 40, 0, 0), color: asset.color }] } : a))} className="px-1.5 py-0.5 bg-gray-100 rounded hover:bg-gray-200 text-[10px]">‚ñ°</button>
                                    <button onClick={() => setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: [...(a.shapes || []), { type: 'polygon', points: createTrianglePath(40, 40, 0, 0), color: asset.color }] } : a))} className="px-1.5 py-0.5 bg-gray-100 rounded hover:bg-gray-200 text-[10px]">‚ñΩ</button>
                                    <button onClick={() => setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: [...(a.shapes || []), { type: 'ellipse', cx: 30, cy: 30, rx: 30, ry: 30, startAngle: 0, endAngle: 360, arcMode: 'sector', color: asset.color }] } : a))} className="px-1.5 py-0.5 bg-green-100 rounded hover:bg-green-200 text-[10px]" title="Ê•ïÂÜÜ/ÊâáÂΩ¢">‚óî</button>
                                </div>
                            </div>
                            <div className="space-y-1 max-h-32 overflow-y-auto scrollbar-thin">
                                {(asset.shapes || []).map((s, i) => (
                                    <div key={i} onClick={() => { setSelectedShapeIndex(i); setSelectedPointIndex(null); }} className={`flex justify-between items-center text-xs p-1 rounded border cursor-pointer ${selectedShapeIndex === i ? 'bg-blue-50 border-blue-300' : 'hover:bg-gray-50'}`}>
                                        <span className="font-bold text-gray-500">#{i + 1} {s.type}</span>
                                        <button onClick={(e) => { e.stopPropagation(); if (!confirm('ÂâäÈô§Ôºü')) return; const newShapes = asset.shapes.filter((_, idx) => idx !== i); setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a)); setSelectedShapeIndex(null); }} className="text-red-400 hover:text-red-600 px-1">√ó</button>
                                    </div>
                                ))}
                            </div>
                        </div>

                        <div className="pt-4 border-t space-y-2">
                            <button onClick={fork} className="btn-action bg-blue-50 border border-blue-200 text-blue-600 hover:bg-blue-100">
                                <Icon p={Icons.Copy} size={14} /> „Ç≥„Éî„Éº„Åó„Å¶‰øùÂ≠ò
                            </button>
                            <button onClick={publish} className="btn-action bg-white border border-blue-200 text-blue-600 hover:bg-blue-50">
                                <Icon p={Icons.Globe} size={14} /> ÂÖ±ÈÄö„É©„Ç§„Éñ„É©„É™„Å´ÁôªÈå≤
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [projects, setProjects] = useState([]);
            const [currentProjectId, setCurrentProjectId] = useState(null);
            const [mode, setMode] = useState('layout');
            const [viewState, setViewState] = useState({ x: 50, y: 50, scale: 1 });
            const [localAssets, setLocalAssets] = useState([]);
            const [globalAssets, setGlobalAssets] = useState([]);
            const [instances, setInstances] = useState([]);

            const [selectedIds, setSelectedIds] = useState([]);
            const [designTargetId, setDesignTargetId] = useState(null);
            const [selectedShapeIndex, setSelectedShapeIndex] = useState(null);
            const [selectedPointIndex, setSelectedPointIndex] = useState(null);
            const [colorPalette, setColorPalette] = useState([]);

            // URL„Éë„Çπ„Åã„ÇâÁèæÂú®„ÅÆ„Éö„Éº„Ç∏„ÇíÂà§ÂÆö
            const currentPath = window.location.pathname;
            const isLibraryPage = currentPath === '/library' || currentPath === '/library/';

            // „Éë„É¨„ÉÉ„Éà„Å´Ëâ≤„ÇíËøΩÂä†
            const addToPalette = (color) => {
                if (!colorPalette.includes(color)) {
                    const newPalette = [...colorPalette, color];
                    setColorPalette(newPalette);
                    API.savePalette({ colors: newPalette });
                }
            };

            // ÂàùÊúü„É≠„Éº„Éâ
            useEffect(() => {
                API.getProjects().then(setProjects);
                // „Ç∞„É≠„Éº„Éê„É´„Ç¢„Çª„ÉÉ„Éà„Å´source: 'global'„Çí‰ªò‰∏é
                API.getAssets().then(assets => setGlobalAssets(assets.map(a => ({ ...a, source: 'global' }))));
                // „Ç´„É©„Éº„Éë„É¨„ÉÉ„Éà„ÇíË™≠„ÅøËæº„Åø
                API.getPalette().then(data => setColorPalette(data.colors || []));
            }, []);

            // „Éó„É≠„Ç∏„Çß„ÇØ„Éà„É≠„Éº„Éâ („Ç∞„É≠„Éº„Éê„É´„Ç¢„Çª„ÉÉ„Éà„ÇíËá™Âãï„Éï„Ç©„Éº„ÇØ)
            useEffect(() => {
                if (!currentProjectId) return;
                API.getProjectData(currentProjectId).then(data => {
                    let loadedAssets = data.assets || [];

                    // „Ç∞„É≠„Éº„Éê„É´„Ç¢„Çª„ÉÉ„Éà„ÇíËá™ÂãïÁöÑ„Å´„É≠„Éº„Ç´„É´„Å´„Éï„Ç©„Éº„ÇØ
                    // Êó¢„Å´Âêå„ÅòÂêçÂâç„ÅÆ„É≠„Éº„Ç´„É´„Ç¢„Çª„ÉÉ„Éà„Åå„Å™„Åë„Çå„Å∞„Ç≥„Éî„Éº„Çí‰ΩúÊàê
                    const localAssetNames = new Set(loadedAssets.map(a => a.name));
                    const forkedAssets = globalAssets
                        .filter(ga => !localAssetNames.has(ga.name))
                        .map(ga => ({ ...ga, id: `a-fork-${ga.id}-${Date.now()}`, source: undefined }));

                    setLocalAssets([...loadedAssets, ...forkedAssets]);
                    setInstances(data.instances || []);
                });
            }, [currentProjectId, globalAssets]);

            // Ëá™Âãï‰øùÂ≠ò (Á∞°Êòì)
            useEffect(() => {
                if (!currentProjectId) return;
                const timer = setTimeout(() => {
                    API.saveProjectData(currentProjectId, { assets: localAssets, instances });
                }, 1000);
                return () => clearTimeout(timer);
            }, [localAssets, instances, currentProjectId]);

            const handleCreateProject = async () => {
                const name = prompt("„Éó„É≠„Ç∏„Çß„ÇØ„ÉàÂêç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ", "Êñ∞Ë¶è„Éó„É≠„Ç∏„Çß„ÇØ„Éà");
                if (!name) return;
                const newProj = await API.createProject(name);
                setProjects(p => [...p, newProj]);
            };

            const handleDeleteProject = async (e, id) => {
                e.stopPropagation();
                if (!confirm("„Åì„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü")) return;
                await API.deleteProject(id);
                setProjects(p => p.filter(proj => proj.id !== id));
            };

            const handleRenameProject = async (id, name) => {
                await API.updateProjectName(id, name);
                setProjects(p => p.map(proj => proj.id === id ? { ...proj, name } : proj));
            };

            const handleAddInstance = (assetId) => {
                let asset = [...localAssets, ...globalAssets].find(a => a.id === assetId);
                let targetAssetId = assetId;

                // „Ç∞„É≠„Éº„Éê„É´„Ç¢„Çª„ÉÉ„Éà„ÅÆÂ†¥Âêà„ÄÅËá™ÂãïÁöÑ„Å´„É≠„Éº„Ç´„É´„Ç≥„Éî„Éº„Çí‰ΩúÊàê
                if (asset && asset.source === 'global') {
                    const newLocalId = `a-fork-${Date.now()}`;
                    const newLocalAsset = { ...asset, id: newLocalId, name: asset.name, source: undefined };
                    setLocalAssets(prev => [...prev, newLocalAsset]);
                    targetAssetId = newLocalId;
                    asset = newLocalAsset;
                }

                const newInst = {
                    id: `i-${Date.now()}`,
                    assetId: targetAssetId,
                    x: (400 - viewState.x) / viewState.scale / BASE_SCALE,
                    y: (300 - viewState.y) / viewState.scale / BASE_SCALE,
                    rotation: 0,
                    locked: false,
                    type: asset ? asset.type : 'unknown'
                };
                setInstances(prev => [...prev, newInst]);
                setSelectedIds([newInst.id]);
            };

            const handleAddText = () => {
                const newInst = {
                    id: `t-${Date.now()}`,
                    type: 'text',
                    text: '„ÉÜ„Ç≠„Çπ„Éà',
                    fontSize: 24,
                    color: '#333333',
                    x: (400 - viewState.x) / viewState.scale / BASE_SCALE,
                    y: (300 - viewState.y) / viewState.scale / BASE_SCALE,
                    rotation: 0,
                    locked: false
                };
                setInstances(prev => [...prev, newInst]);
                setSelectedIds([newInst.id]);
            };

            // „É©„Ç§„Éñ„É©„É™ÁÆ°ÁêÜÁîªÈù¢
            if (isLibraryPage) {
                return (
                    <div className="min-h-screen bg-gray-100 overflow-auto">
                        {/* Header */}
                        <div className="bg-white border-b shadow-sm p-4 flex items-center justify-between">
                            <div className="flex items-center gap-4">
                                <a href="/" className="text-gray-500 hover:text-gray-800 flex items-center gap-2">
                                    <Icon p={Icons.LogOut} /> Êàª„Çã
                                </a>
                                <h1 className="text-xl font-bold text-gray-800">ÂÖ±ÈÄö„É©„Ç§„Éñ„É©„É™ÁÆ°ÁêÜ</h1>
                            </div>
                        </div>

                        <div className="max-w-4xl mx-auto p-6 space-y-8">
                            {/* „Ç´„É©„Éº„Éë„É¨„ÉÉ„ÉàÁÆ°ÁêÜ */}
                            <div className="bg-white rounded-lg shadow p-6">
                                <h2 className="text-lg font-bold text-gray-700 mb-4 flex items-center gap-2">
                                    üé® „Ç´„É©„Éº„Éë„É¨„ÉÉ„Éà
                                </h2>
                                <div className="grid grid-cols-10 gap-2 mb-4">
                                    {colorPalette.map((color, i) => (
                                        <div key={i} className="relative group">
                                            <div
                                                className="w-10 h-10 rounded border-2 border-gray-300"
                                                style={{ backgroundColor: color }}
                                                title={color}
                                            />
                                            <button
                                                onClick={() => {
                                                    const newPalette = colorPalette.filter((_, idx) => idx !== i);
                                                    setColorPalette(newPalette);
                                                    API.savePalette({ colors: newPalette });
                                                }}
                                                className="absolute -top-1 -right-1 w-4 h-4 bg-red-500 text-white rounded-full text-[10px] opacity-0 group-hover:opacity-100 transition"
                                            >
                                                √ó
                                            </button>
                                        </div>
                                    ))}
                                    {/* Êñ∞Ë¶èËâ≤ËøΩÂä† */}
                                    <label className="w-10 h-10 rounded border-2 border-dashed border-gray-300 flex items-center justify-center cursor-pointer hover:border-blue-400 hover:bg-blue-50 transition">
                                        <input
                                            type="color"
                                            className="sr-only"
                                            onChange={(e) => {
                                                const newColor = e.target.value;
                                                if (!colorPalette.includes(newColor)) {
                                                    const newPalette = [...colorPalette, newColor];
                                                    setColorPalette(newPalette);
                                                    API.savePalette({ colors: newPalette });
                                                }
                                            }}
                                        />
                                        <Icon p={Icons.Plus} size={16} className="text-gray-400" />
                                    </label>
                                </div>
                                <p className="text-xs text-gray-400">„ÇØ„É™„ÉÉ„ÇØ„ÅßÂâäÈô§„ÄÅ+ „Éú„Çø„É≥„ÅßÊñ∞„Åó„ÅÑËâ≤„ÇíËøΩÂä†</p>
                            </div>

                            {/* ÂÖ±ÈÄö„Ç¢„Çª„ÉÉ„ÉàÁÆ°ÁêÜ */}
                            <div className="bg-white rounded-lg shadow p-6">
                                <div className="flex items-center justify-between mb-4">
                                    <h2 className="text-lg font-bold text-gray-700 flex items-center gap-2">
                                        üì¶ ÂÖ±ÈÄö„Ç¢„Çª„ÉÉ„Éà
                                    </h2>
                                    <button
                                        onClick={async () => {
                                            try {
                                                const data = globalAssets.map(a => ({ ...a, source: undefined }));
                                                console.log('Saving assets:', data);
                                                const res = await API.saveAssets(data);
                                                console.log('Save response:', res);
                                                alert('ÂÖ±ÈÄö„Ç¢„Çª„ÉÉ„Éà„Çí‰øùÂ≠ò„Åó„Åæ„Åó„Åü');
                                            } catch (e) {
                                                console.error('Save failed:', e);
                                                alert('‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + e.message);
                                            }
                                        }}
                                        className="text-xs bg-green-50 text-green-600 px-3 py-1 rounded border border-green-200 hover:bg-green-100"
                                    >
                                        Â§âÊõ¥„Çí‰øùÂ≠ò
                                    </button>
                                </div>
                                <div className="flex gap-6">
                                    {/* „Ç¢„Çª„ÉÉ„Éà‰∏ÄË¶ß */}
                                    <div className="flex-1">
                                        <div className="grid grid-cols-3 gap-3">
                                            {globalAssets.map(asset => (
                                                <div
                                                    key={asset.id}
                                                    onClick={() => setDesignTargetId(designTargetId === asset.id ? null : asset.id)}
                                                    className={`border rounded p-3 relative group cursor-pointer transition ${designTargetId === asset.id
                                                        ? 'bg-blue-50 border-blue-400 ring-2 ring-blue-200'
                                                        : 'bg-gray-50 hover:bg-gray-100'
                                                        }`}
                                                >
                                                    <div className="w-10 h-10 mx-auto rounded mb-2 border" style={{ backgroundColor: asset.color }} />
                                                    <div className="text-xs font-bold text-gray-700 text-center truncate">{asset.name}</div>
                                                    <div className="text-[10px] text-gray-400 text-center">{asset.type}</div>
                                                    <button
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            if (!confirm(`"${asset.name}" „ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`)) return;
                                                            const newAssets = globalAssets.filter(a => a.id !== asset.id);
                                                            setGlobalAssets(newAssets);
                                                            API.saveAssets(newAssets.map(a => ({ ...a, source: undefined })));
                                                            if (designTargetId === asset.id) setDesignTargetId(null);
                                                        }}
                                                        className="absolute top-1 right-1 text-gray-300 hover:text-red-500 opacity-0 group-hover:opacity-100 transition p-1"
                                                    >
                                                        <Icon p={Icons.Trash} size={12} />
                                                    </button>
                                                </div>
                                            ))}
                                        </div>
                                        {globalAssets.length === 0 && (
                                            <div className="text-center py-8 text-gray-400">
                                                ÂÖ±ÈÄö„Ç¢„Çª„ÉÉ„Éà„ÅØ„Åæ„Å†„ÅÇ„Çä„Åæ„Åõ„Çì
                                            </div>
                                        )}
                                    </div>

                                    {/* Á∑®ÈõÜ„Éë„Éç„É´ */}
                                    {designTargetId && (() => {
                                        const editAsset = globalAssets.find(a => a.id === designTargetId);
                                        if (!editAsset) return null;
                                        const updateAsset = (key, value) => {
                                            const newAssets = globalAssets.map(a =>
                                                a.id === designTargetId ? { ...a, [key]: value } : a
                                            );
                                            setGlobalAssets(newAssets);
                                        };
                                        return (
                                            <div className="w-64 bg-gray-50 border rounded-lg p-4 space-y-4">
                                                <div className="flex items-center justify-between">
                                                    <h3 className="font-bold text-sm text-gray-700">„Ç¢„Çª„ÉÉ„ÉàÁ∑®ÈõÜ</h3>
                                                    <button onClick={() => setDesignTargetId(null)} className="text-gray-400 hover:text-gray-600">√ó</button>
                                                </div>

                                                {/* „Éó„É¨„Éì„É•„Éº */}
                                                <div className="flex justify-center">
                                                    <div className="w-20 h-20 rounded border-2" style={{ backgroundColor: editAsset.color }} />
                                                </div>

                                                {/* ÂêçÁß∞ */}
                                                <div>
                                                    <label className="text-xs font-bold text-gray-500 block mb-1">ÂêçÁß∞</label>
                                                    <input
                                                        value={editAsset.name}
                                                        onChange={e => updateAsset('name', e.target.value)}
                                                        className="w-full px-2 py-1 border rounded text-sm"
                                                    />
                                                </div>

                                                {/* Á®ÆÈ°û */}
                                                <div>
                                                    <label className="text-xs font-bold text-gray-500 block mb-1">Á®ÆÈ°û</label>
                                                    <select
                                                        value={editAsset.type}
                                                        onChange={e => updateAsset('type', e.target.value)}
                                                        className="w-full px-2 py-1 border rounded text-sm"
                                                    >
                                                        <option value="room">ÈÉ®Â±ã„ÉªÂ∫ä</option>
                                                        <option value="fixture">Ë®≠ÂÇô„ÉªÂª∫ÂÖ∑</option>
                                                        <option value="furniture">ÂÆ∂ÂÖ∑</option>
                                                    </select>
                                                </div>

                                                {/* Ëâ≤ */}
                                                <div>
                                                    <label className="text-xs font-bold text-gray-500 block mb-1">Ëâ≤</label>
                                                    <ColorPicker
                                                        value={editAsset.color}
                                                        onChange={c => updateAsset('color', c)}
                                                        palette={colorPalette}
                                                        onAddToPalette={addToPalette}
                                                    />
                                                </div>

                                                {/* „Çµ„Ç§„Ç∫ */}
                                                <div className="grid grid-cols-2 gap-2">
                                                    <div>
                                                        <label className="text-xs font-bold text-gray-500 block mb-1">ÂπÖ (mm)</label>
                                                        <input
                                                            type="number"
                                                            value={editAsset.w || 100}
                                                            onChange={e => updateAsset('w', Number(e.target.value))}
                                                            className="w-full px-2 py-1 border rounded text-sm"
                                                        />
                                                    </div>
                                                    <div>
                                                        <label className="text-xs font-bold text-gray-500 block mb-1">È´ò„Åï (mm)</label>
                                                        <input
                                                            type="number"
                                                            value={editAsset.h || 100}
                                                            onChange={e => updateAsset('h', Number(e.target.value))}
                                                            className="w-full px-2 py-1 border rounded text-sm"
                                                        />
                                                    </div>
                                                </div>

                                                {/* ‰øùÂ≠ò„Éú„Çø„É≥ */}
                                                <button
                                                    onClick={() => {
                                                        API.saveAssets(globalAssets.map(a => ({ ...a, source: undefined })));
                                                        alert('‰øùÂ≠ò„Åó„Åæ„Åó„Åü');
                                                    }}
                                                    className="w-full bg-blue-600 text-white text-sm py-2 rounded hover:bg-blue-700 transition"
                                                >
                                                    ‰øùÂ≠ò
                                                </button>
                                            </div>
                                        );
                                    })()}
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            if (!currentProjectId) {
                return (
                    <div className="p-8 bg-gray-100 min-h-screen">
                        <div className="max-w-4xl mx-auto">
                            <div className="flex items-center justify-between mb-6">
                                <h1 className="text-2xl font-bold text-gray-700">„Éó„É≠„Ç∏„Çß„ÇØ„Éà‰∏ÄË¶ß</h1>
                                <a href="/library" className="text-sm text-blue-600 hover:underline flex items-center gap-1">
                                    <Icon p={Icons.Settings} size={14} /> ÂÖ±ÈÄö„É©„Ç§„Éñ„É©„É™ÁÆ°ÁêÜ
                                </a>
                            </div>
                            <div className="grid grid-cols-4 gap-4">
                                <div onClick={handleCreateProject} className="h-40 border-2 border-dashed border-gray-300 rounded-lg flex flex-col items-center justify-center text-gray-400 cursor-pointer hover:bg-gray-50 hover:border-blue-400 hover:text-blue-500 transition">
                                    <Icon p={Icons.Plus} size={32} />
                                    <span className="mt-2 font-bold">Êñ∞Ë¶è‰ΩúÊàê</span>
                                </div>
                                {projects.map(p => (
                                    <ProjectCard key={p.id} project={p} onOpen={() => setCurrentProjectId(p.id)} onDelete={handleDeleteProject} onRename={handleRenameProject} />
                                ))}
                            </div>
                        </div>
                    </div>
                );
            }

            const activeProject = projects.find(p => p.id === currentProjectId);

            // ÂÖ±ÈÄö„Ç¢„Çª„ÉÉ„ÉàID„Åã„Çâ„Ç¢„Çª„ÉÉ„Éà„ÇíÂèñÂæóÔºà„Åæ„Åü„ÅØ„É≠„Éº„Ç´„É´„ÇíÂê´„ÇÅ„Å¶Ê§úÁ¥¢Ôºâ
            const allAssets = [...localAssets, ...globalAssets];

            return (
                <div className="flex h-screen overflow-hidden">
                    {/* Size: 260px Sidebar */}
                    <div className="w-64 flex-shrink-0 border-r bg-white flex flex-col z-20 shadow-sm">
                        <div className="p-3 border-b flex items-center justify-between bg-gray-50">
                            <button onClick={() => setCurrentProjectId(null)} className="text-gray-500 hover:text-gray-800 p-1 rounded hover:bg-gray-200"><Icon p={Icons.LogOut} /></button>
                            <span className="font-bold text-sm truncate px-2">{activeProject?.name}</span>
                            <div className="w-6"></div>
                        </div>
                        <UnifiedSidebar
                            mode={mode}
                            assets={localAssets}
                            onAddInstance={handleAddInstance}
                            onAddText={handleAddText}
                            setLocalAssets={setLocalAssets}
                            setGlobalAssets={setGlobalAssets}
                            setDesignTargetId={setDesignTargetId}
                            designTargetId={designTargetId}
                            instances={instances}
                            setInstances={setInstances}
                        />
                    </div>

                    {/* Main Canvas */}
                    <div className="flex-1 relative bg-gray-100 overflow-hidden relative">
                        <div className={`absolute inset-0 ${mode === 'layout' ? 'grid-bg' : 'design-grid'}`}></div>

                        {/* Toolbar - „É´„Éº„É©„Éº„ÅÆ‰∏ã„Å´ÈÖçÁΩÆ */}
                        <div className="absolute top-6 left-6 z-30 bg-white p-1 rounded shadow-md border flex gap-1">
                            <button onClick={() => setMode('layout')} className={`px-3 py-1.5 rounded text-xs font-bold flex items-center gap-2 ${mode === 'layout' ? 'bg-blue-100 text-blue-700' : 'text-gray-500 hover:bg-gray-50'}`}>
                                <Icon p={Icons.Move} size={14} /> „É¨„Ç§„Ç¢„Ç¶„Éà
                            </button>
                            <button onClick={() => { setMode('design'); if (!designTargetId && localAssets.length > 0) setDesignTargetId(localAssets[0].id); }} className={`px-3 py-1.5 rounded text-xs font-bold flex items-center gap-2 ${mode === 'design' ? 'bg-orange-100 text-orange-700' : 'text-gray-500 hover:bg-gray-50'}`}>
                                <Icon p={Icons.Pen} size={14} /> „Éë„Éº„ÉÑË®≠Ë®à
                            </button>
                        </div>

                        {/* Scale Controls */}
                        <div className="absolute bottom-4 left-4 z-30 bg-white p-1 rounded shadow-md border flex gap-1">
                            <button onClick={() => setViewState(p => ({ ...p, scale: p.scale * 1.2 }))} className="p-1.5 rounded hover:bg-gray-100 text-gray-600"><Icon p={Icons.ZoomIn} /></button>
                            <span className="px-2 py-1 text-xs min-w-[3rem] text-center">{Math.round(viewState.scale * 100)}%</span>
                            <button onClick={() => setViewState(p => ({ ...p, scale: p.scale / 1.2 }))} className="p-1.5 rounded hover:bg-gray-100 text-gray-600"><Icon p={Icons.ZoomOut} /></button>
                        </div>

                        <Ruler viewState={viewState} />

                        {mode === 'layout' ? (
                            <LayoutCanvas
                                viewState={viewState} setViewState={setViewState}
                                assets={allAssets}
                                instances={instances} setInstances={setInstances}
                                selectedIds={selectedIds} setSelectedIds={setSelectedIds}
                            />
                        ) : (
                            <DesignCanvas
                                viewState={viewState} setViewState={setViewState}
                                assets={allAssets}
                                designTargetId={designTargetId} setLocalAssets={setLocalAssets}
                                setGlobalAssets={setGlobalAssets}
                                selectedShapeIndex={selectedShapeIndex} setSelectedShapeIndex={setSelectedShapeIndex}
                                selectedPointIndex={selectedPointIndex} setSelectedPointIndex={setSelectedPointIndex}
                            />
                        )}
                    </div>

                    {/* Right Properties Panel */}
                    <div className="w-72 flex-shrink-0 border-l bg-white z-20 shadow-sm flex flex-col">
                        {mode === 'layout' ? (
                            <LayoutProperties
                                instances={instances} setInstances={setInstances}
                                selectedIds={selectedIds} assets={allAssets} setSelectedIds={setSelectedIds}
                                setMode={setMode} setDesignTargetId={setDesignTargetId}
                            />
                        ) : (
                            <DesignProperties
                                assets={allAssets} designTargetId={designTargetId}
                                setLocalAssets={setLocalAssets} setGlobalAssets={setGlobalAssets}
                                selectedShapeIndex={selectedShapeIndex} setSelectedShapeIndex={setSelectedShapeIndex}
                                selectedPointIndex={selectedPointIndex} setSelectedPointIndex={setSelectedPointIndex}
                                setDesignTargetId={setDesignTargetId}
                                palette={colorPalette} onAddToPalette={addToPalette}
                            />
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>