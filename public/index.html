<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ÈñìÂèñ„Çä„Ç¢„Éº„Ç≠„ÉÜ„ÇØ„Éà Pro v6.3</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        body {
            font-family: "Helvetica Neue", Arial, "Hiragino Kaku Gothic ProN", "Hiragino Sans", Meiryo, sans-serif;
            user-select: none;
            overflow: hidden;
        }

        .grid-bg {
            background-color: #f8fafc;
            background-image: radial-gradient(#cbd5e1 1px, transparent 1px);
            background-size: 40px 40px;
        }

        .design-grid {
            background-color: #fff7ed;
            background-image:
                linear-gradient(to right, #fed7aa 1px, transparent 1px),
                linear-gradient(to bottom, #fed7aa 1px, transparent 1px);
            background-size: 20px 20px;
        }

        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        .scrollbar-thin::-webkit-scrollbar {
            width: 6px;
        }

        .scrollbar-thin::-webkit-scrollbar-track {
            background: transparent;
        }

        .scrollbar-thin::-webkit-scrollbar-thumb {
            background-color: #cbd5e1;
            border-radius: 3px;
        }

        /* „Ç≠„É£„É≥„Éê„ÇπÁî®„Çπ„ÇØ„É≠„Éº„É´„Éê„Éº */
        .canvas-scroll::-webkit-scrollbar {
            width: 12px;
            height: 12px;
        }

        .canvas-scroll::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 6px;
        }

        .canvas-scroll::-webkit-scrollbar-thumb {
            background-color: #94a3b8;
            border-radius: 6px;
            border: 2px solid #f1f5f9;
        }

        .canvas-scroll::-webkit-scrollbar-thumb:hover {
            background-color: #64748b;
        }

        .canvas-scroll::-webkit-scrollbar-corner {
            background: #f1f5f9;
        }

        /* ÂÖ±ÈÄöUI„Éë„Éº„ÉÑ */
        .sidebar-header {
            font-size: 0.85rem;
            font-weight: bold;
            color: #4b5563;
            padding: 0.75rem;
            border-bottom: 1px solid #e5e7eb;
            background-color: #f9fafb;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .prop-row {
            display: grid;
            grid-template-columns: 80px 1fr;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .prop-label {
            font-size: 0.75rem;
            font-weight: bold;
            color: #6b7280;
            text-align: right;
        }

        .prop-input {
            width: 100%;
            border: 1px solid #d1d5db;
            border-radius: 0.25rem;
            padding: 0.25rem 0.5rem;
            font-size: 0.85rem;
            text-align: right;
            background-color: white;
        }

        .prop-input:focus {
            outline: none;
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.2);
        }

        .btn-action {
            width: 100%;
            padding: 0.4rem;
            font-size: 0.8rem;
            font-weight: bold;
            border-radius: 0.25rem;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.25rem;
        }
    </style>
</head>

<body class="bg-gray-100 h-screen text-gray-700">
    <div id="root" class="h-full flex flex-col"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;
        // --- Ë®≠ÂÆö ---
        const BASE_SCALE = 2.0;
        const SNAP_UNIT = 5;
        const LAYERS = { room: 0, fixture: 1, furniture: 2, text: 3 };
        const toMM = (val) => Math.round(val * 10);
        const fromMM = (val) => val / 10;

        // --- „Ç¢„Ç§„Ç≥„É≥ (SVG) ---
        const Icon = ({ p, size = 18, className = "" }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}>{p}</svg>
        );
        const Icons = {
            Home: <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" />,
            Plus: <path d="M12 5v14M5 12h14" />,
            Trash: <path d="M3 6h18M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2" />,
            Move: <path d="M5 9l-3 3 3 3M9 5l3-3 3 3M19 9l3 3-3 3M9 19l3 3 3-3M2 12h20M12 2v20" />,
            Pen: <path d="M12 19l7-7 3 3-7 7-3-3zM18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5zM2 2l7.586 7.586" />,
            Type: <path d="M4 7V4h16v3M9 20h6M12 4v16" />,
            Check: <path d="M20 6L9 17l-5-5" />,
            LogOut: <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4M16 17l5-5-5-5M21 12H9" />,
            Folder: <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z" />,
            ZoomIn: <g><circle cx="11" cy="11" r="8" /><line x1="21" y1="21" x2="16.65" y2="16.65" /><line x1="11" y1="8" x2="11" y2="14" /><line x1="8" y1="11" x2="14" y2="11" /></g>,
            ZoomOut: <g><circle cx="11" cy="11" r="8" /><line x1="21" y1="21" x2="16.65" y2="16.65" /><line x1="8" y1="11" x2="14" y2="11" /></g>,
            Lock: <g><rect x="3" y="11" width="18" height="11" rx="2" ry="2" /><path d="M7 11V7a5 5 0 0 1 10 0v4" /></g>,
            Unlock: <g><rect x="3" y="11" width="18" height="11" rx="2" ry="2" /><path d="M7 11V7a5 5 0 0 1 9.9-1" /></g>,
            Globe: <g><circle cx="12" cy="12" r="10" /><line x1="2" y1="12" x2="22" y2="12" /><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1 4-10z" /></g>,
            Settings: <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.18-.08a2 2 0 0 0-2 0l-.45.45a2 2 0 0 0 0 2l.08.18a2 2 0 0 1 0 2l-.25.43a2 2 0 0 1-1-1.73 1H2a2 2 0 0 0-2 2v.44a2 2 0 0 0 2 2h.18a2 2 0 0 1 1.73 1l.25.43a2 2 0 0 1 0 2l-.08.18a2 2 0 0 0 0 2l.45.45a2 2 0 0 0 2 0l.18-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V2a2 2 0 0 0-2-2z" />,
            Poly: <path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5" />,
            Circle: <circle cx="12" cy="12" r="10" />,
            Square: <rect x="3" y="3" width="18" height="18" rx="2" ry="2" />,
            ArrowUpRight: <path d="M7 17l9.2-9.2M17 17V7H7" />,
            Target: <g><circle cx="12" cy="12" r="10" /><line x1="12" y1="8" x2="12" y2="16" /><line x1="8" y1="12" x2="16" y2="12" /></g>,
            Box: <path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z" />,
            Copy: <g><rect x="9" y="9" width="13" height="13" rx="2" ry="2" /><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" /></g>,
            Magnet: <g><path d="M6 15v-5a6 6 0 1 1 12 0v5" strokeWidth="2" /><path d="M6 15h4v4h-4z" fill="currentColor" /><path d="M14 15h4v4h-4z" fill="currentColor" /></g>
        };

        // --- API ---
        const API = {
            getAssets: () => fetch('/api/assets').then(r => r.json()).then(res => res.data),
            saveAssets: (d) => fetch('/api/assets', { method: 'POST', body: JSON.stringify(d) }).then(r => r.json()),
            getPalette: () => fetch('/api/palette').then(r => r.json()).then(res => res.data),
            savePalette: (d) => fetch('/api/palette', { method: 'POST', body: JSON.stringify(d) }).then(r => r.json()),
            getProjects: () => fetch('/api/projects').then(r => r.json()).then(res => res.data),
            createProject: (name) => fetch('/api/projects', { method: 'POST', body: JSON.stringify({ name }) }).then(r => r.json()).then(res => res.data),
            getProjectData: (id) => fetch(`/api/projects/${id}`).then(r => r.json()).then(res => res.data),
            saveProjectData: (id, d) => fetch(`/api/projects/${id}`, { method: 'PUT', body: JSON.stringify(d) }).then(r => r.json()),
            deleteProject: (id) => fetch(`/api/projects/${id}`, { method: 'DELETE' }).then(r => r.json()),
            updateProjectName: (id, name) => fetch(`/api/projects/${id}`, { method: 'PATCH', body: JSON.stringify({ name }) }).then(r => r.json()),
        };

        // --- Utils ---
        const createRectPath = (w, h, x = 0, y = 0) => [
            { x: x, y: y, h1: { x: 0, y: 0 }, h2: { x: 0, y: 0 }, isCurve: false },
            { x: x + w, y: y, h1: { x: 0, y: 0 }, h2: { x: 0, y: 0 }, isCurve: false },
            { x: x + w, y: y + h, h1: { x: 0, y: 0 }, h2: { x: 0, y: 0 }, isCurve: false },
            { x: x, y: y + h, h1: { x: 0, y: 0 }, h2: { x: 0, y: 0 }, isCurve: false },
        ];
        const createTrianglePath = (w, h, x = 0, y = 0) => [
            { x: x + w / 2, y: y, h1: { x: 0, y: 0 }, h2: { x: 0, y: 0 }, isCurve: false },
            { x: x + w, y: y + h, h1: { x: 0, y: 0 }, h2: { x: 0, y: 0 }, isCurve: false },
            { x: x, y: y + h, h1: { x: 0, y: 0 }, h2: { x: 0, y: 0 }, isCurve: false },
        ];
        const normalizeAsset = (asset) => {
            if (!asset) return null;
            let shapes = asset.shapes || [];
            if (shapes.length === 0) {
                if (asset.shape === 'rect' || !asset.shape) {
                    shapes.push({ type: 'polygon', points: createRectPath(asset.w || 60, asset.h || 60), color: asset.color });
                } else if (asset.shape === 'polygon' && asset.points) {
                    const pts = asset.points.map(p => ({ x: p.x, y: p.y, h1: { x: 0, y: 0 }, h2: { x: 0, y: 0 }, isCurve: false }));
                    shapes.push({ type: 'polygon', points: pts, color: asset.color });
                } else if (asset.shape === 'circle') {
                    shapes.push({ type: 'circle', x: 0, y: 0, w: asset.w || 60, h: asset.h || 60, color: asset.color });
                }
            }
            return { ...asset, shapes, w: asset.w || 60, h: asset.h || 60 };
        };

        // Êñ∞„Åó„ÅÑ„Éë„ÇπÁîüÊàêÔºöhandlesÈÖçÂàóÂØæÂøú
        // handles: [] = Áõ¥Á∑ö, handles: [{x,y}] = ‰∫åÊ¨°„Éô„Ç∏„Çß, handles: [{x,y},{x,y}] = ‰∏âÊ¨°„Éô„Ç∏„Çß, „Åù„Çå‰ª•‰∏ä = ÈÄ£Á∂öÊõ≤Á∑ö
        const generateSvgPath = (points) => {
            if (!points || points.length === 0) return "";
            let d = `M ${points[0].x * BASE_SCALE} ${points[0].y * BASE_SCALE}`;
            for (let i = 0; i < points.length; i++) {
                const curr = points[i];
                const next = points[(i + 1) % points.length];
                const handles = curr.handles || [];

                if (handles.length === 0) {
                    // ÊóßÂΩ¢Âºè„Å®„ÅÆ‰∫íÊèõ: isCurve/h1/h2„Åå„ÅÇ„ÇãÂ†¥Âêà
                    if (curr.isCurve || next.isCurve) {
                        const cp1x = (curr.x + (curr.h2?.x || 0)) * BASE_SCALE;
                        const cp1y = (curr.y + (curr.h2?.y || 0)) * BASE_SCALE;
                        const cp2x = (next.x + (next.h1?.x || 0)) * BASE_SCALE;
                        const cp2y = (next.y + (next.h1?.y || 0)) * BASE_SCALE;
                        d += ` C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${next.x * BASE_SCALE} ${next.y * BASE_SCALE}`;
                    } else {
                        d += ` L ${next.x * BASE_SCALE} ${next.y * BASE_SCALE}`;
                    }
                } else if (handles.length === 1) {
                    // ‰∫åÊ¨°„Éô„Ç∏„ÇßÊõ≤Á∑ö (Q)
                    const h = handles[0];
                    d += ` Q ${h.x * BASE_SCALE} ${h.y * BASE_SCALE}, ${next.x * BASE_SCALE} ${next.y * BASE_SCALE}`;
                } else if (handles.length === 2) {
                    // ‰∏âÊ¨°„Éô„Ç∏„ÇßÊõ≤Á∑ö (C)
                    const h1 = handles[0];
                    const h2 = handles[1];
                    d += ` C ${h1.x * BASE_SCALE} ${h1.y * BASE_SCALE}, ${h2.x * BASE_SCALE} ${h2.y * BASE_SCALE}, ${next.x * BASE_SCALE} ${next.y * BASE_SCALE}`;
                } else {
                    // Ë§áÊï∞„ÅÆ„Éè„É≥„Éâ„É´: ÈÄ£Á∂öÊõ≤Á∑ö„Å®„Åó„Å¶ÊèèÁîª
                    const step = 1 / handles.length;
                    let lastX = curr.x, lastY = curr.y;
                    for (let j = 0; j < handles.length; j++) {
                        const h = handles[j];
                        const t = (j + 1) * step;
                        const endX = curr.x + (next.x - curr.x) * t;
                        const endY = curr.y + (next.y - curr.y) * t;
                        d += ` Q ${h.x * BASE_SCALE} ${h.y * BASE_SCALE}, ${endX * BASE_SCALE} ${endY * BASE_SCALE}`;
                        lastX = endX; lastY = endY;
                    }
                    // ÊúÄÂæå„ÅÆÁÇπ„Å∏Áõ¥Á∑ö
                    if (Math.abs(lastX - next.x) > 0.01 || Math.abs(lastY - next.y) > 0.01) {
                        d += ` L ${next.x * BASE_SCALE} ${next.y * BASE_SCALE}`;
                    }
                }
            }
            d += " Z";
            return d;
        };

        // Áµ±‰∏ÄÊ•ïÂÜÜSVG„Éë„ÇπÁîüÊàêÔºàÊ•ïÂÜÜ„ÉªÊâáÂΩ¢„ÉªÂºìÂΩ¢ÂØæÂøúÔºâ
        const generateEllipsePath = (shape) => {
            const { cx = 0, cy = 0, rx = 50, ry = 50, startAngle = 0, endAngle = 360, arcMode = 'sector', rotation = 0 } = shape;
            const rxs = rx * BASE_SCALE;
            const rys = ry * BASE_SCALE;
            const cxs = cx * BASE_SCALE;
            const cys = cy * BASE_SCALE;

            // ÂÆåÂÖ®„Å™Ê•ïÂÜÜ„ÅÆÂ†¥Âêà
            const angleDiff = ((endAngle - startAngle + 360) % 360) || 360;
            if (angleDiff >= 360) {
                // ÂÆåÂÖ®„Å™Ê•ïÂÜÜ„ÅØ2„Å§„ÅÆÂÜÜÂºß„ÅßÊèèÁîª
                return `M ${cxs - rxs} ${cys} A ${rxs} ${rys} 0 1 1 ${cxs + rxs} ${cys} A ${rxs} ${rys} 0 1 1 ${cxs - rxs} ${cys}`;
            }

            // ÈÉ®ÂàÜÂÜÜÂºß„ÅÆÂ†¥Âêà
            const startRad = (startAngle * Math.PI) / 180;
            const endRad = (endAngle * Math.PI) / 180;

            // Ê•ïÂÜÜ‰∏ä„ÅÆÂßãÁÇπ„ÉªÁµÇÁÇπ
            const x1 = cxs + rxs * Math.cos(startRad);
            const y1 = cys + rys * Math.sin(startRad);
            const x2 = cxs + rxs * Math.cos(endRad);
            const y2 = cys + rys * Math.sin(endRad);

            const largeArc = angleDiff > 180 ? 1 : 0;
            const sweepFlag = 1;

            if (arcMode === 'sector') {
                // ÊâáÂΩ¢: ‰∏≠ÂøÉ‚ÜíÂßãÁÇπ‚ÜíÂÜÜÂºß‚ÜíÁµÇÁÇπ‚Üí‰∏≠ÂøÉ
                return `M ${cxs} ${cys} L ${x1} ${y1} A ${rxs} ${rys} 0 ${largeArc} ${sweepFlag} ${x2} ${y2} Z`;
            } else {
                // ÂºìÂΩ¢(chord): ÂßãÁÇπ‚ÜíÂÜÜÂºß‚ÜíÁµÇÁÇπ‚ÜíÂßãÁÇπ
                return `M ${x1} ${y1} A ${rxs} ${rys} 0 ${largeArc} ${sweepFlag} ${x2} ${y2} Z`;
            }
        };

        const getClientPos = (e, viewState, svgRect) => {
            const cx = e.clientX - svgRect.left;
            const cy = e.clientY - svgRect.top;
            const x = (cx - viewState.x) / viewState.scale / BASE_SCALE;
            const y = (cy - viewState.y) / viewState.scale / BASE_SCALE;
            return { x, y };
        };

        // --- Common Leaf Components ---

        const RenderAssetShapes = ({ item, isSelected }) => {
            const shapes = (item.shapes && item.shapes.length > 0)
                ? item.shapes
                : [{ type: item.shape || 'rect', w: item.w, h: item.h, x: 0, y: 0, color: item.color, points: item.points || createRectPath(item.w, item.h) }];
            return (
                <g>
                    {shapes.map((s, i) => {
                        const style = { fill: s.color || item.color, stroke: isSelected ? "#3b82f6" : "#999", strokeWidth: isSelected ? 3 : 1 };
                        const rot = s.rotation || 0;
                        const rotateTransform = rot ? `rotate(${rot} ${(s.cx || 0) * BASE_SCALE} ${(s.cy || 0) * BASE_SCALE})` : '';
                        if (s.type === 'circle') return <ellipse key={i} cx={(s.x + s.w / 2) * BASE_SCALE} cy={(s.y + s.h / 2) * BASE_SCALE} rx={s.w * BASE_SCALE / 2} ry={s.h * BASE_SCALE / 2} {...style} />;
                        if (s.type === 'ellipse') return <path key={i} d={generateEllipsePath(s)} transform={rotateTransform} {...style} />;
                        if (s.type === 'polygon' && s.points) return <path key={i} d={generateSvgPath(s.points)} {...style} />;
                        return <rect key={i} x={s.x * BASE_SCALE} y={s.y * BASE_SCALE} width={s.w * BASE_SCALE} height={s.h * BASE_SCALE} rx={2} {...style} />;
                    })}
                </g>
            );
        };

        const RenderItem = ({ item, isSelected, onDown }) => (
            <g
                transform={`translate(${item.x * BASE_SCALE}, ${item.y * BASE_SCALE}) rotate(${item.rotation})`}
                onPointerDown={e => { e.stopPropagation(); onDown(e, item.id); }}
                className="hover:opacity-90"
                style={{ cursor: 'grab', opacity: isSelected ? 0.85 : 1 }}
            >
                {item.type === 'text' ? (
                    <g>
                        {isSelected && <rect x="-5" y="-25" width="100" height="35" fill="rgba(59,130,246,0.1)" stroke="#3b82f6" strokeWidth="2" strokeDasharray="4" />}
                        <text fill={item.color} fontSize={item.fontSize} fontWeight="bold" style={{ whiteSpace: 'pre', userSelect: 'none' }}>{item.text}</text>
                    </g>
                ) : (
                    <g>
                        <RenderAssetShapes item={item} isSelected={isSelected} />
                        {isSelected && <g className="pointer-events-none">
                            {/* ‰ΩçÁΩÆË°®Á§∫ (ÂéüÁÇπ„Åã„Çâ„ÅÆË∑ùÈõ¢) */}
                            <text x={-15} y={-15} textAnchor="end" fontSize="9" fill="#666" fontWeight="bold">({toMM(item.x)}, {toMM(item.y)})</text>
                            {/* „Çµ„Ç§„Ç∫Ë°®Á§∫ */}
                            <line x1={0} y1={-10} x2={item.w * BASE_SCALE} y2={-10} stroke="blue" strokeWidth="1" />
                            <text x={item.w * BASE_SCALE / 2} y={-12} textAnchor="middle" fontSize="10" fill="blue">{toMM(item.w)}mm</text>
                            <line x1={-10} y1={0} x2={-10} y2={item.h * BASE_SCALE} stroke="blue" strokeWidth="1" />
                            <text x={-12} y={item.h * BASE_SCALE / 2} textAnchor="end" dominantBaseline="middle" fontSize="10" fill="blue">{toMM(item.h)}mm</text>
                            {/* ÈÅ∏Êäû„Éè„Ç§„É©„Ç§„Éà */}
                            <rect x={-2} y={-2} width={item.w * BASE_SCALE + 4} height={item.h * BASE_SCALE + 4} fill="none" stroke="#3b82f6" strokeWidth="2" strokeDasharray="6 3" />
                        </g>}
                        <text x={item.w * BASE_SCALE / 2} y={item.h * BASE_SCALE / 2} textAnchor="middle" dominantBaseline="middle" fontSize={12} fill="#333" pointerEvents="none" style={{ userSelect: 'none', textShadow: '0 0 2px white' }}>{item.name}</text>
                    </g>
                )}
            </g>
        );

        const Ruler = ({ viewState }) => {
            const width = 3000;
            const height = 3000; const step = 100;
            const offsetX = viewState.x; const offsetY = viewState.y;
            const scale = viewState.scale * BASE_SCALE;
            const xTicks = []; const yTicks = [];
            for (let i = 0; i < width; i += step) {
                const x = offsetX + i * scale;
                if (x > 20) xTicks.push(<g key={`x${i}`}><line x1={x} y1={0} x2={x} y2={15} stroke="#888" strokeWidth="1" /><text x={x + 2} y={12} fontSize="10" fill="#555">{i}</text></g>);
            }
            for (let i = 0; i < height; i += step) {
                const y = offsetY + i * scale;
                if (y > 20) yTicks.push(<g key={`y${i}`}><line x1={0} y1={y} x2={15} y2={y} stroke="#888" strokeWidth="1" /><text x={2} y={y + 10} fontSize="10" fill="#555">{i}</text></g>);
            }
            return (
                <div className="absolute inset-0 pointer-events-none z-0">
                    <svg width="100%" height="20" className="absolute top-0 left-0 bg-white/90 border-b z-10">{xTicks}</svg>
                    <svg width="20" height="100%" className="absolute top-0 left-0 bg-white/90 border-r z-10">{yTicks}</svg>
                </div>
            );
        };

        const ProjectCard = ({ project, onOpen, onDelete, onRename }) => {
            const [name, setName] = useState(project.name);
            useEffect(() => setName(project.name), [project.name]);
            const handleBlur = () => { if (name !== project.name) onRename(project.id, name); };
            const handleKeyDown = (e) => { if (e.key === 'Enter') e.currentTarget.blur(); };
            return (
                <div onClick={onOpen} className="h-40 bg-white border rounded-lg shadow-sm hover:shadow-md p-4 flex flex-col cursor-pointer relative group transition">
                    <div className="flex-1 flex flex-col items-center justify-center">
                        <Icon p={Icons.Folder} size={40} className="text-orange-200 mb-2" />
                        <input value={name} onClick={e => e.stopPropagation()} onChange={e => setName(e.target.value)} onBlur={handleBlur} onKeyDown={handleKeyDown} className="text-center font-bold text-lg w-full bg-transparent border-b border-transparent focus:border-blue-500 outline-none text-gray-700" />
                    </div>
                    <button onClick={(e) => onDelete(e, project.id)} className="absolute top-2 right-2 p-2 text-gray-300 hover:text-red-500 opacity-0 group-hover:opacity-100 transition"><Icon p={Icons.Trash} /></button>
                </div>
            );
        };
        const EditableTitle = ({ name, onRename }) => {
            const [val, setVal] = useState(name);
            useEffect(() => setVal(name), [name]);
            const handleBlur = () => { if (val !== name) onRename(val); };
            const handleKeyDown = (e) => { if (e.key === 'Enter') e.currentTarget.blur(); };
            return <input value={val} onChange={e => setVal(e.target.value)} onBlur={handleBlur} onKeyDown={handleKeyDown} className="font-bold text-lg text-gray-800 bg-transparent border-b border-transparent hover:border-gray-300 focus:border-blue-500 outline-none px-1" style={{ minWidth: '200px' }} />;
        };

        const AssetFilter = ({ filter, setFilter }) => (
            <div className="flex p-2 gap-1 bg-gray-50 border-b shrink-0">
                <button onClick={() => setFilter('local')} className={`flex-1 py-1 text-[10px] rounded border transition ${filter === 'local' ? 'bg-white border-orange-300 shadow-sm font-bold text-orange-600' : 'border-transparent text-gray-400 hover:bg-gray-100'}`}>„É≠„Éº„Ç´„É´</button>
                <button onClick={() => setFilter('global')} className={`flex-1 py-1 text-[10px] rounded border transition ${filter === 'global' ? 'bg-white border-blue-300 shadow-sm font-bold text-blue-600' : 'border-transparent text-gray-400 hover:bg-gray-100'}`}>ÂÖ±ÈÄö</button>
            </div>
        );

        // --- „Ç´„É©„Éº„Éî„ÉÉ„Ç´„Éº „Ç≥„É≥„Éù„Éº„Éç„É≥„Éà ---
        const ColorPicker = ({ value, onChange, palette, onAddToPalette }) => {
            const [showMore, setShowMore] = useState(false);
            const [showCustom, setShowCustom] = useState(false);
            const [customColor, setCustomColor] = useState(value || '#cccccc');

            const handleCustomChange = (e) => {
                setCustomColor(e.target.value);
                onChange(e.target.value);
            };

            const handleAddToPalette = () => {
                if (onAddToPalette && !palette.includes(customColor)) {
                    onAddToPalette(customColor);
                }
            };

            const colors = palette || [];
            const firstRow = colors.slice(0, 5);
            const moreColors = colors.slice(5);

            return (
                <div className="space-y-1">
                    {/* 1Ë°åÁõÆ: ÊúÄÂàù„ÅÆ5Ëâ≤ */}
                    <div className="flex gap-1 items-center">
                        {firstRow.map((color, i) => (
                            <button
                                key={i}
                                onClick={() => { onChange(color); setShowMore(false); }}
                                className={`w-6 h-6 rounded border-2 transition hover:scale-110 ${value === color ? 'border-blue-500 ring-2 ring-blue-200' : 'border-gray-300'}`}
                                style={{ backgroundColor: color }}
                                title={color}
                            />
                        ))}
                        {moreColors.length > 0 && (
                            <button
                                onClick={() => setShowMore(!showMore)}
                                className="w-6 h-6 rounded border-2 border-dashed border-gray-300 text-gray-400 text-[10px] hover:border-blue-400 hover:text-blue-500"
                                title={showMore ? 'Èñâ„Åò„Çã' : '„ÇÇ„Å£„Å®Ë¶ã„Çã'}
                            >
                                {showMore ? '‚àí' : `+${moreColors.length}`}
                            </button>
                        )}
                        <button
                            onClick={() => setShowCustom(!showCustom)}
                            className="w-6 h-6 rounded border-2 border-dashed border-gray-300 flex items-center justify-center hover:border-blue-400"
                            title="„Ç´„Çπ„Çø„É†Ëâ≤"
                        >
                            <span className="text-[10px]">üé®</span>
                        </button>
                    </div>

                    {/* Â±ïÈñãÊôÇ: ÊÆã„Çä„ÅÆËâ≤ */}
                    {showMore && moreColors.length > 0 && (
                        <div className="grid grid-cols-5 gap-1 p-2 bg-gray-50 rounded border">
                            {moreColors.map((color, i) => (
                                <button
                                    key={i}
                                    onClick={() => { onChange(color); setShowMore(false); }}
                                    className={`w-6 h-6 rounded border-2 transition hover:scale-110 ${value === color ? 'border-blue-500 ring-2 ring-blue-200' : 'border-gray-300'}`}
                                    style={{ backgroundColor: color }}
                                    title={color}
                                />
                            ))}
                        </div>
                    )}

                    {/* „Ç´„Çπ„Çø„É†„Ç´„É©„Éº */}
                    {showCustom && (
                        <div className="flex gap-2 items-center p-2 bg-gray-50 rounded border">
                            <input
                                type="color"
                                value={customColor}
                                onChange={handleCustomChange}
                                className="w-8 h-6 cursor-pointer border rounded"
                            />
                            <button
                                onClick={handleAddToPalette}
                                className="text-[10px] px-2 py-0.5 bg-green-50 text-green-600 border border-green-200 rounded hover:bg-green-100"
                                title="„Éë„É¨„ÉÉ„Éà„Å´ËøΩÂä†"
                            >
                                +ËøΩÂä†
                            </button>
                            <button
                                onClick={() => setShowCustom(false)}
                                className="text-[10px] text-gray-400 hover:text-gray-600"
                            >
                                Èñâ„Åò„Çã
                            </button>
                        </div>
                    )}
                </div>
            );
        };

        // --- Canvas Components ---

        const DesignCanvasRender = ({ viewState, asset, shapes, selectedShapeIndices, selectedPointIndex, onDown, onMove, onUp, onDeleteShape, svgRef, marquee }) => (
            <div className="w-full h-full absolute top-0 left-0 overflow-auto canvas-scroll pt-5 pl-5"
                onPointerDown={e => onDown(e, null)}
                onPointerMove={onMove}
                onPointerUp={onUp}
                ref={svgRef}
            >
                <svg width="3000" height="3000" style={{ minWidth: '3000px', minHeight: '3000px' }}>
                    <g transform={`translate(${viewState.x}, ${viewState.y}) scale(${viewState.scale})`}>
                        <line x1="-5000" y1="0" x2="5000" y2="0" stroke="#ccc" strokeWidth="2" />
                        <line x1="0" y1="-5000" x2="0" y2="5000" stroke="#ccc" strokeWidth="2" />
                        <circle cx="0" cy="0" r="5" fill="red" opacity="0.5" />
                        {asset && (
                            <g>
                                <rect x="0" y="0" width={asset.w * BASE_SCALE} height={asset.h * BASE_SCALE} fill="none" stroke="blue" strokeWidth="1" strokeDasharray="4 2" opacity="0.3" pointerEvents="none" />
                                {shapes.map((s, i) => {
                                    const isSelected = selectedShapeIndices.includes(i);
                                    const style = { fill: s.color || asset.color, stroke: isSelected ? "#3b82f6" : "#999", strokeWidth: isSelected ? 2 : 1, cursor: 'move' };
                                    const rot = s.rotation || 0;
                                    const rotateTransform = rot && s.type === 'ellipse' ? `rotate(${rot} ${(s.cx || 0) * BASE_SCALE} ${(s.cy || 0) * BASE_SCALE})` : '';
                                    return (
                                        <g key={i} onPointerDown={(e) => onDown(e, i)}>
                                            {s.type === 'circle'
                                                ? <ellipse cx={(s.x + s.w / 2) * BASE_SCALE} cy={(s.y + s.h / 2) * BASE_SCALE} rx={s.w * BASE_SCALE / 2} ry={s.h * BASE_SCALE / 2} {...style} />
                                                : s.type === 'ellipse'
                                                    ? <path d={generateEllipsePath(s)} transform={rotateTransform} {...style} />
                                                    : <path d={generateSvgPath(s.points)} {...style} />
                                            }
                                            {/* Á∑®ÈõÜ„Éè„É≥„Éâ„É´ (ÂÄãÂà•Ë°®Á§∫) */}
                                            {isSelected && s.type === 'ellipse' && (() => {
                                                const cx = (s.cx || 0) * BASE_SCALE;
                                                const cy = (s.cy || 0) * BASE_SCALE;
                                                const rxs = (s.rx || 50) * BASE_SCALE;
                                                const rys = (s.ry || 50) * BASE_SCALE;
                                                const startAngle = s.startAngle || 0;
                                                const endAngle = s.endAngle || 360;
                                                const startRad = startAngle * Math.PI / 180;
                                                const endRad = endAngle * Math.PI / 180;
                                                const sx = cx + rxs * Math.cos(startRad);
                                                const sy = cy + rys * Math.sin(startRad);
                                                const ex = cx + rxs * Math.cos(endRad);
                                                const ey = cy + rys * Math.sin(endRad);
                                                // ÂõûËª¢„Éè„É≥„Éâ„É´‰ΩçÁΩÆÔºà‰∏äÈÉ®Ôºâ
                                                const rotHandleY = cy - rys - 20;
                                                return (
                                                    <g transform={rotateTransform}>
                                                        {/* ‰∏≠ÂøÉÁÇπ */}
                                                        <circle cx={cx} cy={cy} r="6" fill="red" stroke="white" strokeWidth="2" className="cursor-move" />
                                                        {/* Ê®™ÂçäÂæÑ„Éè„É≥„Éâ„É´ÔºàÂè≥Ôºâ- ÁÇπÁ∑ö„Å™„Åó */}
                                                        <rect x={cx + rxs - 4} y={cy - 4} width="8" height="8" fill="orange" stroke="white" strokeWidth="1" className="cursor-ew-resize" onPointerDown={(e) => onDown(e, i, 'rx')} />
                                                        {/* Á∏¶ÂçäÂæÑ„Éè„É≥„Éâ„É´Ôºà‰∏ãÔºâ- ÁÇπÁ∑ö„Å™„Åó */}
                                                        <rect x={cx - 4} y={cy + rys - 4} width="8" height="8" fill="orange" stroke="white" strokeWidth="1" className="cursor-ns-resize" onPointerDown={(e) => onDown(e, i, 'ry')} />
                                                        {/* ÊØîÁéáÁ∂≠ÊåÅ„Éè„É≥„Éâ„É´ÔºàÂè≥‰∏ãÔºâ */}
                                                        <rect x={cx + rxs - 4} y={cy + rys - 4} width="8" height="8" fill="yellow" stroke="orange" strokeWidth="1" className="cursor-nwse-resize" onPointerDown={(e) => onDown(e, i, 'rxy')} />
                                                        {/* ÂõûËª¢„Éè„É≥„Éâ„É´ */}
                                                        <line x1={cx} y1={cy - rys} x2={cx} y2={rotHandleY} stroke="cyan" strokeWidth="1" strokeDasharray="3,2" />
                                                        <circle cx={cx} cy={rotHandleY} r="5" fill="cyan" stroke="white" strokeWidth="1" className="cursor-pointer" onPointerDown={(e) => onDown(e, i, 'rotation')} />
                                                        {/* ËßíÂ∫¶„Éè„É≥„Éâ„É´Ôºà60%„ÅÆ‰ΩçÁΩÆ„Å´ÈÖçÁΩÆ„Åó„Å¶ÂàÜÈõ¢Ôºâ */}
                                                        <line x1={cx} y1={cy} x2={sx * 0.6 + cx * 0.4} y2={sy * 0.6 + cy * 0.4} stroke="green" strokeWidth="1" strokeDasharray="3,2" />
                                                        <line x1={cx} y1={cy} x2={ex * 0.6 + cx * 0.4} y2={ey * 0.6 + cy * 0.4} stroke="purple" strokeWidth="1" strokeDasharray="3,2" />
                                                        <circle cx={sx * 0.6 + cx * 0.4} cy={sy * 0.6 + cy * 0.4} r="5" fill="green" stroke="white" strokeWidth="1" className="cursor-pointer" onPointerDown={(e) => onDown(e, i, 'startAngle')} />
                                                        <circle cx={ex * 0.6 + cx * 0.4} cy={ey * 0.6 + cy * 0.4} r="5" fill="purple" stroke="white" strokeWidth="1" className="cursor-pointer" onPointerDown={(e) => onDown(e, i, 'endAngle')} />
                                                    </g>
                                                );
                                            })()}
                                            {isSelected && s.type === 'polygon' && s.points.map((p, pid) => (
                                                <React.Fragment key={pid}>
                                                    {/* È†ÇÁÇπ */}
                                                    <circle cx={p.x * BASE_SCALE} cy={p.y * BASE_SCALE} r="5" fill={selectedPointIndex === pid ? "red" : "white"} stroke="blue" strokeWidth="2" className="cursor-crosshair" onPointerDown={(e) => onDown(e, i, pid)} />
                                                    {/* Âà∂Âæ°ÁÇπ */}
                                                    {p.handles && p.handles.map((h, hid) => (
                                                        <React.Fragment key={`h-${pid}-${hid}`}>
                                                            <line x1={p.x * BASE_SCALE} y1={p.y * BASE_SCALE} x2={h.x * BASE_SCALE} y2={h.y * BASE_SCALE} stroke="orange" strokeWidth="1" strokeDasharray="3,2" />
                                                            <rect x={h.x * BASE_SCALE - 4} y={h.y * BASE_SCALE - 4} width="8" height="8" fill="orange" stroke="darkorange" strokeWidth="1" className="cursor-move" onPointerDown={(e) => onDown(e, i, pid, null, hid)} />
                                                        </React.Fragment>
                                                    ))}
                                                </React.Fragment>
                                            ))}
                                            {isSelected && s.type === 'polygon' && (() => {
                                                const maxX = Math.max(...s.points.map(p => p.x));
                                                const minY = Math.min(...s.points.map(p => p.y));
                                                return (
                                                    <g transform={`translate(${maxX * BASE_SCALE + 10}, ${minY * BASE_SCALE - 10})`} className="cursor-pointer" onPointerDown={(e) => onDeleteShape(i)}>
                                                        <circle r="8" fill="red" />
                                                        <line x1="-4" y1="-4" x2="4" y2="4" stroke="white" strokeWidth="2" /><line x1="4" y1="-4" x2="-4" y2="4" stroke="white" strokeWidth="2" />
                                                    </g>
                                                );
                                            })()}
                                            {isSelected && (s.type === 'circle' || s.type === 'rect') && (
                                                <g>
                                                    <rect x={(s.x + s.w - 5 / BASE_SCALE) * BASE_SCALE} y={(s.y + s.h - 5 / BASE_SCALE) * BASE_SCALE} width="10" height="10" fill="yellow" stroke="blue" strokeWidth="2" className="cursor-nwse-resize" onPointerDown={(e) => onDown(e, i, null, 'both')} />
                                                    <rect x={(s.x + s.w - 5 / BASE_SCALE) * BASE_SCALE} y={(s.y + s.h / 2 - 5 / BASE_SCALE) * BASE_SCALE} width="10" height="10" fill="lightblue" stroke="blue" strokeWidth="2" className="cursor-ew-resize" onPointerDown={(e) => onDown(e, i, null, 'horizontal')} />
                                                    <rect x={(s.x + s.w / 2 - 5 / BASE_SCALE) * BASE_SCALE} y={(s.y + s.h - 5 / BASE_SCALE) * BASE_SCALE} width="10" height="10" fill="lightgreen" stroke="blue" strokeWidth="2" className="cursor-ns-resize" onPointerDown={(e) => onDown(e, i, null, 'vertical')} />
                                                    <g transform={`translate(${(s.x + s.w) * BASE_SCALE + 10}, ${s.y * BASE_SCALE - 10})`} className="cursor-pointer" onPointerDown={(e) => onDeleteShape(i)}>
                                                        <circle r="8" fill="red" />
                                                        <line x1="-4" y1="-4" x2="4" y2="4" stroke="white" strokeWidth="2" /><line x1="4" y1="-4" x2="-4" y2="4" stroke="white" strokeWidth="2" />
                                                    </g>
                                                </g>
                                            )}
                                            {/* ÂØ∏Ê≥ïË°®Á§∫ (ÈÅ∏ÊäûÊôÇ„ÅÆ„Åø) */}
                                            {isSelected && (() => {
                                                const fontSize = 12;
                                                const textFill = "blue";
                                                const strokeColor = "blue";
                                                const strokeWidth = 1;
                                                const offset = 15;

                                                if (s.type === 'circle' && (s.w || s.h)) {
                                                    // Radius
                                                    const cx = (s.x + s.w / 2) * BASE_SCALE;
                                                    const cy = (s.y + s.h / 2) * BASE_SCALE;
                                                    const r = (s.w / 2); // Âçò‰Ωç„Å™„Åó
                                                    return (
                                                        <g pointerEvents="none">
                                                            <line x1={cx} y1={cy} x2={cx + s.w * BASE_SCALE / 2} y2={cy} stroke={strokeColor} strokeWidth={strokeWidth} strokeDasharray="2,2" />
                                                            <text x={cx + s.w * BASE_SCALE / 4} y={cy - 5} fill={textFill} fontSize={fontSize} textAnchor="middle">r: {Math.round(r)}</text>
                                                        </g>
                                                    );
                                                } else if (s.type === 'ellipse' && (s.rx || s.ry)) {
                                                    // Radii
                                                    const cx = (s.cx || 0) * BASE_SCALE;
                                                    const cy = (s.cy || 0) * BASE_SCALE;
                                                    const rx = s.rx || 50;
                                                    const ry = s.ry || 50;
                                                    return (
                                                        <g pointerEvents="none" transform={rotateTransform}>
                                                            {/* Rx */}
                                                            <line x1={cx} y1={cy} x2={cx + rx * BASE_SCALE} y2={cy} stroke={strokeColor} strokeWidth={strokeWidth} strokeDasharray="2,2" />
                                                            <text x={cx + rx * BASE_SCALE / 2} y={cy - 5} fill={textFill} fontSize={fontSize} textAnchor="middle">rx: {Math.round(rx)}</text>
                                                            {/* Ry */}
                                                            <line x1={cx} y1={cy} x2={cx} y2={cy + ry * BASE_SCALE} stroke={strokeColor} strokeWidth={strokeWidth} strokeDasharray="2,2" />
                                                            <text x={cx + 5} y={cy + ry * BASE_SCALE / 2} fill={textFill} fontSize={fontSize} textAnchor="start" dominantBaseline="middle">ry: {Math.round(ry)}</text>
                                                        </g>
                                                    );
                                                } else if (s.type === 'polygon' && s.points) {
                                                    // Segment lengths
                                                    return (
                                                        <g pointerEvents="none">
                                                            {s.points.map((p, idx) => {
                                                                const nextP = s.points[(idx + 1) % s.points.length];
                                                                const mx = ((p.x + nextP.x) / 2) * BASE_SCALE;
                                                                const my = ((p.y + nextP.y) / 2) * BASE_SCALE;
                                                                const dist = Math.sqrt(Math.pow(nextP.x - p.x, 2) + Math.pow(nextP.y - p.y, 2));
                                                                return (
                                                                    <text key={idx} x={mx} y={my} fill={textFill} fontSize={fontSize} textAnchor="middle" dominantBaseline="middle" stroke="white" strokeWidth="3" paintOrder="stroke">{Math.round(dist)}</text>
                                                                );
                                                            })}
                                                        </g>
                                                    );
                                                } else {
                                                    // Rect / Image (Width / Height)
                                                    const x = (s.x || 0) * BASE_SCALE;
                                                    const y = (s.y || 0) * BASE_SCALE;
                                                    const w = (s.w || 0);
                                                    const h = (s.h || 0);
                                                    return (
                                                        <g pointerEvents="none">
                                                            {/* Width (Top) */}
                                                            <line x1={x} y1={y - offset} x2={x + w * BASE_SCALE} y2={y - offset} stroke={strokeColor} strokeWidth={strokeWidth} markerEnd="url(#arrow)" markerStart="url(#arrow)" />
                                                            <text x={x + w * BASE_SCALE / 2} y={y - offset - 5} fill={textFill} fontSize={fontSize} textAnchor="middle">{Math.round(w)}</text>
                                                            {/* Height (Left) */}
                                                            <line x1={x - offset} y1={y} x2={x - offset} y2={y + h * BASE_SCALE} stroke={strokeColor} strokeWidth={strokeWidth} markerEnd="url(#arrow)" markerStart="url(#arrow)" />
                                                            <text x={x - offset - 5} y={y + h * BASE_SCALE / 2} fill={textFill} fontSize={fontSize} textAnchor="end" dominantBaseline="middle">{Math.round(h)}</text>
                                                        </g>
                                                    );
                                                }
                                            })()}
                                        </g>
                                    );
                                })}
                            </g>
                        )}
                    </g>
                </svg>
                {/* „Éû„Éº„Ç≠„ÉºÈÅ∏ÊäûÁü©ÂΩ¢ */}
                {marquee && (
                    <div
                        style={{
                            position: 'fixed',
                            left: Math.min(marquee.sx, marquee.ex),
                            top: Math.min(marquee.sy, marquee.ey),
                            width: Math.abs(marquee.ex - marquee.sx),
                            height: Math.abs(marquee.ey - marquee.sy),
                            border: '2px dashed #3b82f6',
                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                            pointerEvents: 'none',
                            zIndex: 9999
                        }}
                    />
                )}
            </div>
        );

        const DesignCanvas = ({ viewState, setViewState, assets, designTargetId, setLocalAssets, selectedShapeIndices, setSelectedShapeIndices, selectedPointIndex, setSelectedPointIndex }) => {
            const dragRef = useRef({ mode: 'idle' });
            const [cursorMode, setCursorMode] = useState('idle');
            const svgRef = useRef(null);
            const [marquee, setMarquee] = useState(null); // „Éû„Éº„Ç≠„ÉºÈÅ∏ÊäûÁî®
            const asset = assets.find(a => a.id === designTargetId);

            const handleDown = (e, shapeIndex = null, pointIndex = null, resizeMode = null, handleIndex = null) => {
                if (svgRef.current && e.pointerId) svgRef.current.setPointerCapture(e.pointerId);
                const rect = svgRef.current.getBoundingClientRect();

                // „Ç≠„É£„É≥„Éê„ÇπÂÖ®‰Ωì„ÅÆÁßªÂãïÔºà‰∏≠„Éú„Çø„É≥„ÅÆ„Åø - ËÉåÊôØ„Éë„É≥„ÅØWASD/Áü¢Âç∞„Ç≠„Éº„ÅßÔºâ
                if (e.button === 1) {
                    dragRef.current = { mode: 'panning', sx: e.clientX, sy: e.clientY, vx: viewState.x, vy: viewState.y };
                    setCursorMode('panning');
                    return;
                }

                // ËÉåÊôØÂ∑¶„ÇØ„É™„ÉÉ„ÇØÊôÇ„ÅØ„Éû„Éº„Ç≠„ÉºÈÅ∏ÊäûÈñãÂßã
                if (shapeIndex === null && e.button === 0) {
                    setMarquee({ sx: e.clientX, sy: e.clientY, ex: e.clientX, ey: e.clientY });
                    if (!e.ctrlKey && !e.metaKey) {
                        setSelectedShapeIndices([]); // Ctrl„Å™„Åó„Å™„ÇâÈÅ∏ÊäûËß£Èô§
                    }
                    dragRef.current = {
                        mode: 'marquee',
                        sx: e.clientX, sy: e.clientY,
                        prevSelectedIndices: e.ctrlKey || e.metaKey ? [...selectedShapeIndices] : []
                    };
                    return;
                }

                // „É™„Çµ„Ç§„Ç∫„Éè„É≥„Éâ„É´„Éâ„É©„ÉÉ„Ç∞
                if (resizeMode && shapeIndex !== null) {
                    e.stopPropagation();
                    setSelectedShapeIndices([shapeIndex]);
                    setSelectedPointIndex(null);
                    const shape = asset.shapes[shapeIndex];
                    dragRef.current = {
                        mode: 'resizing',
                        sx: e.clientX, sy: e.clientY,
                        shapeW: shape.w, shapeH: shape.h,
                        shapeX: shape.x || 0, shapeY: shape.y || 0,
                        resizeMode
                    };
                    setCursorMode('resizing');
                    return;
                }

                // Âà∂Âæ°ÁÇπÔºà„Éè„É≥„Éâ„É´Ôºâ„Éâ„É©„ÉÉ„Ç∞
                if (handleIndex !== null && pointIndex !== null && shapeIndex !== null) {
                    e.stopPropagation();
                    setSelectedShapeIndices([shapeIndex]);
                    setSelectedPointIndex(pointIndex);
                    const shape = asset.shapes[shapeIndex];
                    const handle = shape.points[pointIndex].handles[handleIndex];
                    dragRef.current = { mode: 'draggingHandle', sx: e.clientX, sy: e.clientY, handleX: handle.x, handleY: handle.y, handleIndex };
                    setCursorMode('draggingHandle');
                    return;
                }

                // ËßíÂ∫¶„Éè„É≥„Éâ„É´„Éâ„É©„ÉÉ„Ç∞ÔºàÂÜÜÂºßÁî®Ôºâ
                if ((pointIndex === 'startAngle' || pointIndex === 'endAngle') && shapeIndex !== null) {
                    e.stopPropagation();
                    setSelectedShapeIndices([shapeIndex]);
                    const shape = asset.shapes[shapeIndex];
                    const rect = svgRef.current.getBoundingClientRect();
                    dragRef.current = {
                        mode: 'draggingAngle',
                        targetProp: pointIndex,
                        cx: (shape.cx || 0) * viewState.scale * BASE_SCALE + viewState.x + rect.left,
                        cy: (shape.cy || 0) * viewState.scale * BASE_SCALE + viewState.y + rect.top
                    };
                    setCursorMode('draggingAngle');
                    return;
                }

                // ÂõûËª¢„Éè„É≥„Éâ„É´„Éâ„É©„ÉÉ„Ç∞
                if (pointIndex === 'rotation' && shapeIndex !== null) {
                    e.stopPropagation();
                    setSelectedShapeIndices([shapeIndex]);
                    const shape = asset.shapes[shapeIndex];
                    const rect = svgRef.current.getBoundingClientRect();
                    // „Ç∑„Çß„Ç§„Éó‰∏≠ÂøÉÔºà„Åæ„Åü„ÅØÂõûËª¢‰∏≠ÂøÉÔºâ„ÇíË®àÁÆó
                    let cx = (shape.x || 0) + (shape.w || 0) / 2;
                    let cy = (shape.y || 0) + (shape.h || 0) / 2;
                    if (shape.type === 'ellipse' || shape.type === 'arc') {
                        cx = shape.cx || 0;
                        cy = shape.cy || 0;
                    } else if (shape.type === 'polygon') {
                        // „Éù„É™„Ç¥„É≥„ÅÆ‰∏≠ÂøÉË®àÁÆó„ÅØÁ∞°ÊòìÁöÑ„Å´„Éê„Ç¶„É≥„Éá„Ç£„É≥„Ç∞„Éú„ÉÉ„ÇØ„Çπ‰∏≠ÂøÉ
                        // (Êú¨Êù•„ÅØÈáçÂøÉ„Å™„Å©„ÅåËâØ„ÅÑ„Åå„ÄÅÊó¢Â≠òÂÆüË£Ö„Å´Âêà„Çè„Åõ„Çã„Å™„Çâ„Åù„ÅÆ„Åæ„Åæ)
                    }

                    dragRef.current = {
                        mode: 'draggingRotation',
                        cx: cx * viewState.scale * BASE_SCALE + viewState.x + rect.left,
                        cy: cy * viewState.scale * BASE_SCALE + viewState.y + rect.top,
                        initialRotation: shape.rotation || 0,
                        startAngle: 0 // move„ÅßË®àÁÆó
                    };
                    // move„Åß„ÅÆË®àÁÆóÁî®„Å´startAngle„ÅåÂøÖË¶Å„Å†„Åå„ÄÅ„Åì„Åì„Åß„ÅØ‰∏ÄÊó¶„Éû„Ç¶„Çπ‰ΩçÁΩÆ„Å®„ÅÆËßíÂ∫¶„Çí‰øùÊåÅ
                    const mx = e.clientX;
                    const my = e.clientY;
                    dragRef.current.startAngle = Math.atan2(my - dragRef.current.cy, mx - dragRef.current.cx) * 180 / Math.PI;

                    setCursorMode('draggingRotation');
                    return;
                }

                // ÂçäÂæÑ„Éè„É≥„Éâ„É´„Éâ„É©„ÉÉ„Ç∞ÔºàÂÜÜ„ÉªÂÜÜÂºßÔºâ
                if ((pointIndex === 'rx' || pointIndex === 'ry') && shapeIndex !== null) {
                    e.stopPropagation();
                    setSelectedShapeIndices([shapeIndex]);
                    const shape = asset.shapes[shapeIndex];
                    dragRef.current = {
                        mode: 'draggingRadius',
                        targetProp: pointIndex,
                        sx: e.clientX, sy: e.clientY,
                        initialVal: shape[pointIndex] || 50
                    };
                    setCursorMode('ew-resize'); // Á∞°Êòì
                    return;
                }

                // È†ÇÁÇπ„Éâ„É©„ÉÉ„Ç∞
                if (pointIndex !== null && shapeIndex !== null) {
                    e.stopPropagation();
                    setSelectedShapeIndices([shapeIndex]);
                    setSelectedPointIndex(pointIndex);
                    const shape = asset.shapes[shapeIndex];
                    const pt = shape.points[pointIndex];
                    dragRef.current = { mode: 'draggingPoint', sx: e.clientX, sy: e.clientY, pointX: pt.x, pointY: pt.y };
                    setCursorMode('draggingPoint');
                    return;
                }

                // „Ç∑„Çß„Ç§„Éó„Éâ„É©„ÉÉ„Ç∞ÔºàÁßªÂãïÔºâ
                if (shapeIndex !== null) {
                    e.stopPropagation();

                    let newSelectedIndices = [...selectedShapeIndices];
                    if (e.ctrlKey || e.metaKey) {
                        // „Éà„Ç∞„É´ÈÅ∏Êäû
                        if (newSelectedIndices.includes(shapeIndex)) {
                            newSelectedIndices = newSelectedIndices.filter(i => i !== shapeIndex);
                        } else {
                            newSelectedIndices.push(shapeIndex);
                        }
                        setSelectedShapeIndices(newSelectedIndices);
                        // „Éâ„É©„ÉÉ„Ç∞„ÅØ„Åó„Å™„ÅÑÔºà„Éà„Ç∞„É´„ÅÆ„ÅøÔºâ„Åã„ÄÅ„Éâ„É©„ÉÉ„Ç∞„ÇÇË®±ÂèØ„Åô„Çã„ÅãÔºü
                        // ‰∏ÄËà¨ÁöÑ„Å´„ÅØ„Éà„Ç∞„É´ÊôÇ„ÅØ„Éâ„É©„ÉÉ„Ç∞„Åó„Å™„ÅÑ„Åì„Å®„ÅåÂ§ö„ÅÑ„Åå„ÄÅPowerPointÁ≠â„ÅØ„Éâ„É©„ÉÉ„Ç∞ÂèØËÉΩ„ÄÇ
                        // „Åì„Åì„Åß„ÅØ„Éâ„É©„ÉÉ„Ç∞ÂèØËÉΩ„Å´„Åô„Çã„ÄÇ„Åü„Å†„Åó„Éà„Ç∞„É´„ÅßÈùûÈÅ∏Êäû„Å´„Å™„Å£„ÅüÂ†¥Âêà„ÅØ„Éâ„É©„ÉÉ„Ç∞ÂØæË±°„Åã„ÇâÂ§ñ„Çå„Çã„Åü„ÇÅÊ≥®ÊÑè„ÄÇ
                    } else {
                        // Âçò‰∏ÄÈÅ∏Êäû„Åæ„Åü„ÅØÊó¢Â≠òÈÅ∏Êäû„ÅÆÁ∂≠ÊåÅ
                        if (!newSelectedIndices.includes(shapeIndex)) {
                            newSelectedIndices = [shapeIndex];
                            setSelectedShapeIndices(newSelectedIndices);
                        }
                        // Êó¢„Å´ÈÅ∏ÊäûÊ∏à„Åø„ÅÆÂ†¥Âêà„ÅØÈÅ∏ÊäûÁ∂≠ÊåÅÔºà„Ç∞„É´„Éº„ÉóÁßªÂãï„ÅÆ„Åü„ÇÅÔºâ
                    }

                    // ÈÅ∏Êäû„Åï„Çå„Å¶„ÅÑ„Çã„Ç∑„Çß„Ç§„Éó„Åå„Å™„Åë„Çå„Å∞ÁµÇ‰∫ÜÔºà„Éà„Ç∞„É´„ÅßÂÖ®ÈÉ®Ê∂à„Åà„ÅüÂ†¥Âêà„Å™„Å©Ôºâ
                    if (newSelectedIndices.length === 0) return;

                    // ÈÅ∏Êäû‰∏≠„ÅÆÂÖ®„Ç∑„Çß„Ç§„Éó„ÅÆÂàùÊúü‰ΩçÁΩÆ„Çí‰øùÂ≠ò
                    const initialShapes = newSelectedIndices.map(i => ({
                        index: i,
                        // deep copy
                        data: JSON.parse(JSON.stringify(asset.shapes[i]))
                    }));

                    const anchorIndex = newSelectedIndices[0];
                    const anchorShape = asset.shapes[anchorIndex];
                    const anchorX = anchorShape.x !== undefined ? anchorShape.x : (anchorShape.cx !== undefined ? anchorShape.cx : 0);
                    const anchorY = anchorShape.y !== undefined ? anchorShape.y : (anchorShape.cy !== undefined ? anchorShape.cy : 0);

                    dragRef.current = {
                        mode: 'draggingShape',
                        sx: e.clientX, sy: e.clientY,
                        initialShapes: initialShapes,
                        anchorX, anchorY
                    };
                    setCursorMode('draggingShape');
                    return;
                }

                // ÈÅ∏ÊäûËß£Èô§ („Åì„Åì„Å´„ÅØÂà∞ÈÅî„Åó„Å™„ÅÑ„ÅØ„Åö„Å†„ÅåÂøµ„ÅÆ„Åü„ÇÅ)
                setSelectedShapeIndices([]);
                setSelectedPointIndex(null);
            };

            const handleMove = (e) => {
                const mode = dragRef.current.mode;
                if (mode === 'idle') return;
                e.preventDefault();

                if (mode === 'panning') {
                    const dx = e.clientX - dragRef.current.sx;
                    const dy = e.clientY - dragRef.current.sy;
                    setViewState(p => ({ ...p, x: dragRef.current.vx + dx, y: dragRef.current.vy + dy }));
                } else if (mode === 'marquee') {
                    // „Éû„Éº„Ç≠„ÉºÁü©ÂΩ¢Êõ¥Êñ∞
                    setMarquee(prev => prev ? { ...prev, ex: e.clientX, ey: e.clientY } : null);

                    // „Éû„Éº„Ç≠„ÉºÈÅ∏ÊäûÂá¶ÁêÜ
                    if (svgRef.current) {
                        const rect = svgRef.current.getBoundingClientRect();
                        const scale = viewState.scale * BASE_SCALE;
                        const toWorld = (screenX, screenY) => ({
                            x: (screenX - rect.left - viewState.x) / scale,
                            y: (screenY - rect.top - viewState.y) / scale
                        });

                        const p1 = toWorld(dragRef.current.sx, dragRef.current.sy);
                        const p2 = toWorld(e.clientX, e.clientY);
                        const minX = Math.min(p1.x, p2.x);
                        const maxX = Math.max(p1.x, p2.x);
                        const minY = Math.min(p1.y, p2.y);
                        const maxY = Math.max(p1.y, p2.y);

                        const inBoxIndices = asset.shapes.map((s, i) => {
                            // „Éê„Ç¶„É≥„Éá„Ç£„É≥„Ç∞„Éú„ÉÉ„ÇØ„Çπ„ÅßÂà§ÂÆö
                            const sx = s.x || 0;
                            const sy = s.y || 0;
                            const sw = s.w || 0;
                            const sh = s.h || 0;
                            // „Ç∑„Çß„Ç§„Éó„ÅÆ‰∏≠ÂøÉ„Åæ„Åü„ÅØÁØÑÂõ≤„Åå‰∫§Â∑Æ„Åô„Çã„ÅãÔºü„Åì„Åì„Åß„ÅØ‰∏≠ÂøÉÂà§ÂÆö
                            let cx, cy;
                            if (s.type === 'polygon' && s.points) {
                                const xs = s.points.map(p => p.x);
                                const ys = s.points.map(p => p.y);
                                const minPx = Math.min(...xs);
                                const maxPx = Math.max(...xs);
                                const minPy = Math.min(...ys);
                                const maxPy = Math.max(...ys);
                                cx = minPx + (maxPx - minPx) / 2;
                                cy = minPy + (maxPy - minPy) / 2;
                            } else if (s.type === 'ellipse' || s.type === 'arc' || s.type === 'circle') {
                                cx = s.cx !== undefined ? s.cx : (s.x + s.w / 2);
                                cy = s.cy !== undefined ? s.cy : (s.y + s.h / 2);
                            } else {
                                cx = (s.x || 0) + (s.w || 0) / 2;
                                cy = (s.y || 0) + (s.h || 0) / 2;
                            }
                            return (cx >= minX && cx <= maxX && cy >= minY && cy <= maxY) ? i : -1;
                        }).filter(i => i !== -1);

                        // CtrlÊäº„Åó„Å¶„ÇãÂ†¥Âêà„ÅØËøΩÂä†ÈÅ∏Êäû
                        const initialSelected = dragRef.current.prevSelectedIndices || [];
                        const newIndices = [...new Set([...initialSelected, ...inBoxIndices])];
                        setSelectedShapeIndices(newIndices);
                    }
                } else if (mode === 'resizing' && selectedShapeIndices.length > 0) {
                    const dx = (e.clientX - dragRef.current.sx) / viewState.scale / BASE_SCALE;
                    const dy = (e.clientY - dragRef.current.sy) / viewState.scale / BASE_SCALE;
                    const newShapes = [...asset.shapes];
                    const targetIdx = selectedShapeIndices[0]; // Resize„ÅØÂçò‰∏Ä
                    const targetShape = newShapes[targetIdx];
                    const resizeMode = dragRef.current.resizeMode;

                    if (resizeMode === 'both') {
                        const aspect = dragRef.current.shapeW / dragRef.current.shapeH;
                        let newW = dragRef.current.shapeW + dx;
                        let newH = dragRef.current.shapeH + dy;
                        if (!e.shiftKey) {
                            newW = Math.round(newW / SNAP_UNIT) * SNAP_UNIT;
                            newH = Math.round(newH / SNAP_UNIT) * SNAP_UNIT;
                        }
                        newW = Math.max(10, newW);
                        newH = Math.max(10, newH);
                        newShapes[targetIdx] = { ...targetShape, w: newW, h: newH };
                    } else if (resizeMode === 'width') {
                        let newW = dragRef.current.shapeW + dx;
                        if (!e.shiftKey) newW = Math.round(newW / SNAP_UNIT) * SNAP_UNIT;
                        newW = Math.max(10, newW);
                        newShapes[targetIdx] = { ...targetShape, w: newW };
                    } else if (resizeMode === 'height') {
                        let newH = dragRef.current.shapeH + dy;
                        if (!e.shiftKey) newH = Math.round(newH / SNAP_UNIT) * SNAP_UNIT;
                        newH = Math.max(10, newH);
                        newShapes[targetIdx] = { ...targetShape, h: newH };
                    }
                    setLocalAssets(prev => prev.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                } else if (mode === 'draggingShape') {
                    const rawDx = (e.clientX - dragRef.current.sx) / viewState.scale / BASE_SCALE;
                    const rawDy = (e.clientY - dragRef.current.sy) / viewState.scale / BASE_SCALE;

                    let moveX = rawDx;
                    let moveY = rawDy;

                    // „Çπ„Éä„ÉÉ„ÉóË®àÁÆóÔºöÂü∫Ê∫ñ„Å®„Å™„Çã„Ç∑„Çß„Ç§„ÉóÔºà„Ç¢„É≥„Ç´„ÉºÔºâ„ÅÆ‰ΩçÁΩÆ„Çí„Çπ„Éä„ÉÉ„Éó„Åï„Åõ„ÄÅ„Åù„ÅÆÁßªÂãïÈáè„ÇíÂÖ®‰Ωì„Å´ÈÅ©Áî®
                    if (asset.snap && !e.shiftKey) {
                        const anchorX = dragRef.current.anchorX || 0;
                        const anchorY = dragRef.current.anchorY || 0;
                        const targetX = anchorX + rawDx;
                        const targetY = anchorY + rawDy;
                        const snappedX = Math.round(targetX / SNAP_UNIT) * SNAP_UNIT;
                        const snappedY = Math.round(targetY / SNAP_UNIT) * SNAP_UNIT;
                        moveX = snappedX - anchorX;
                        moveY = snappedY - anchorY;
                    }

                    const newShapes = [...asset.shapes];
                    const initialShapes = dragRef.current.initialShapes || [];

                    initialShapes.forEach(({ index, data }) => {
                        let updatedShape = { ...newShapes[index] };

                        // Â∫ßÊ®ôÁßªÂãï
                        if (data.x !== undefined) updatedShape.x = (data.x || 0) + moveX;
                        if (data.y !== undefined) updatedShape.y = (data.y || 0) + moveY;
                        if (data.cx !== undefined) updatedShape.cx = (data.cx || 0) + moveX;
                        if (data.cy !== undefined) updatedShape.cy = (data.cy || 0) + moveY;

                        // PointsÁßªÂãï
                        if (data.points) {
                            updatedShape.points = data.points.map(p => ({ ...p, x: p.x + moveX, y: p.y + moveY }));
                        }

                        newShapes[index] = updatedShape;
                    });

                    setLocalAssets(prev => prev.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));

                } else if (mode === 'draggingPoint' && selectedShapeIndices.length > 0 && selectedPointIndex !== null) {
                    const dx = (e.clientX - dragRef.current.sx) / viewState.scale / BASE_SCALE;
                    const dy = (e.clientY - dragRef.current.sy) / viewState.scale / BASE_SCALE;
                    const newShapes = [...asset.shapes];
                    const targetIdx = selectedShapeIndices[0];

                    const pts = [...newShapes[targetIdx].points];
                    let nx = dragRef.current.pointX + dx;
                    let ny = dragRef.current.pointY + dy;
                    if (!e.shiftKey) {
                        nx = Math.round(nx / SNAP_UNIT) * SNAP_UNIT;
                        ny = Math.round(ny / SNAP_UNIT) * SNAP_UNIT;
                    }

                    pts[selectedPointIndex] = { ...pts[selectedPointIndex], x: nx, y: ny };
                    newShapes[targetIdx].points = pts;

                    // x, y, w, h „ÅÆÂÜçË®àÁÆó (PolygonÁî®)
                    if (newShapes[targetIdx].type === 'polygon') {
                        const xs = pts.map(p => p.x);
                        const ys = pts.map(p => p.y);
                        newShapes[targetIdx].x = Math.min(...xs);
                        newShapes[targetIdx].y = Math.min(...ys);
                        newShapes[targetIdx].w = Math.max(...xs) - newShapes[targetIdx].x;
                        newShapes[targetIdx].h = Math.max(...ys) - newShapes[targetIdx].y;
                    }

                    setLocalAssets(prev => prev.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));

                } else if (mode === 'draggingHandle' && selectedShapeIndices.length > 0 && selectedPointIndex !== null) {
                    const dx = (e.clientX - dragRef.current.sx) / viewState.scale / BASE_SCALE;
                    const dy = (e.clientY - dragRef.current.sy) / viewState.scale / BASE_SCALE;
                    const newShapes = [...asset.shapes];
                    const targetIdx = selectedShapeIndices[0];

                    const pts = [...newShapes[targetIdx].points];
                    const pt = { ...pts[selectedPointIndex] };
                    const handles = [...pt.handles];
                    const hIndex = dragRef.current.handleIndex;

                    handles[hIndex] = {
                        x: dragRef.current.handleX + dx,
                        y: dragRef.current.handleY + dy
                    };
                    pt.handles = handles;
                    pts[selectedPointIndex] = pt;
                    newShapes[targetIdx].points = pts;

                    setLocalAssets(prev => prev.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));

                } else if (mode === 'draggingAngle' && selectedShapeIndices.length > 0) {
                    const targetIdx = selectedShapeIndices[0];
                    const rect = svgRef.current.getBoundingClientRect();
                    const cx = dragRef.current.cx; // screen coord
                    const cy = dragRef.current.cy;
                    const angle = Math.atan2(e.clientY - cy, e.clientX - cx) * 180 / Math.PI;
                    const deg = (angle + 360) % 360; // 0-360

                    const newShapes = [...asset.shapes];
                    // 15Â∫¶„Çπ„Éä„ÉÉ„Éó (Shift„ÇíÊäº„Åó„Å¶„ÅÑ„Å™„ÅÑÊôÇ)
                    const snapped = e.shiftKey ? deg : Math.round(deg / 15) * 15;
                    newShapes[targetIdx][dragRef.current.targetProp] = snapped;
                    setLocalAssets(prev => prev.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));

                } else if (mode === 'draggingRotation' && selectedShapeIndices.length > 0) {
                    const targetIdx = selectedShapeIndices[0];
                    const cx = dragRef.current.cx;
                    const cy = dragRef.current.cy;
                    const currentAngle = Math.atan2(e.clientY - cy, e.clientX - cx) * 180 / Math.PI;
                    const delta = currentAngle - dragRef.current.startAngle;
                    let newRot = (dragRef.current.initialRotation + delta + 360) % 360;

                    // 15Â∫¶„Çπ„Éä„ÉÉ„Éó (Shift„ÇíÊäº„Åó„Å¶„ÅÑ„Å™„ÅÑÊôÇ)
                    if (!e.shiftKey) {
                        newRot = Math.round(newRot / 15) * 15;
                    }

                    const newShapes = [...asset.shapes];
                    newShapes[targetIdx].rotation = newRot;
                    setLocalAssets(prev => prev.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));

                } else if (mode === 'draggingRadius' && selectedShapeIndices.length > 0) {
                    const targetIdx = selectedShapeIndices[0];
                    const newShapes = [...asset.shapes];
                    const scale = viewState.scale * BASE_SCALE;

                    const dx = (e.clientX - dragRef.current.sx) / scale;
                    // ‰∏≠ÂøÉ„Åã„Çâ„ÅÆË∑ùÈõ¢„ÅßÂçäÂæÑ„ÇíÊ±∫„ÇÅ„ÇãÊñπ„ÅåËá™ÁÑ∂„Å†„Åå„ÄÅÁ∞°ÊòìÁöÑ„Å´dx„ÅßÂ¢óÊ∏õ
                    let newVal = dragRef.current.initialVal + dx;
                    if (!e.shiftKey) {
                        newVal = Math.round(newVal / SNAP_UNIT) * SNAP_UNIT;
                    }
                    newVal = Math.max(1, newVal);

                    newShapes[targetIdx][dragRef.current.targetProp] = newVal;
                    setLocalAssets(prev => prev.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                }
            };

            const handleUp = () => {
                setMarquee(null);
                setCursorMode('idle');
                dragRef.current = { mode: 'idle' };
            };

            const handleDeleteShape = (index) => {
                // ÈÖçÂàóÂØæÂøúÔºöindex„Å†„Åë„Åß„Å™„ÅèselectedShapeIndices„Å´Âê´„Åæ„Çå„Çã„ÇÇ„ÅÆ„ÇÇÂâäÈô§ÂØæË±°„Å´„Åó„Åü„ÅÑ„Åå„ÄÅ
                // ÂÄãÂà•ÂâäÈô§„Éú„Çø„É≥„Åã„Çâ„ÅÆÂëº„Å≥Âá∫„Åó„Å™„Çâindex„ÅÆ„Åø„ÄÇ
                if (!confirm('„Åì„ÅÆ„Ç∑„Çß„Ç§„Éó„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü')) return;
                const newShapes = asset.shapes.filter((_, i) => i !== index);
                setLocalAssets(prev => prev.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                // „Ç§„É≥„Éá„ÉÉ„ÇØ„Çπ„Åå„Åö„Çå„Çã„ÅÆ„ÅßÈÅ∏ÊäûËß£Èô§
                setSelectedShapeIndices([]);
            };
            const updateAssetShapes = (newShapes) => {
                let maxX = 0, maxY = 0;
                newShapes.forEach(s => {
                    if (s.points) s.points.forEach(p => { maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); });
                    else { maxX = Math.max(maxX, (s.x || 0) + s.w); maxY = Math.max(maxY, (s.y || 0) + s.h); }
                });
                setLocalAssets(prev => prev.map(a => a.id === designTargetId ? { ...a, shapes: newShapes, w: maxX, h: maxY } : a));
            };
            const shapes = (asset && asset.shapes && asset.shapes.length > 0)
                ? asset.shapes
                : (asset ? [{ type: asset.shape || 'rect', w: asset.w, h: asset.h, x: 0, y: 0, color: asset.color, points: asset.points || createRectPath(asset.w, asset.h) }] : []);

            return <DesignCanvasRender viewState={viewState} asset={asset} shapes={shapes} selectedShapeIndices={selectedShapeIndices} selectedPointIndex={selectedPointIndex} onDown={handleDown} onMove={handleMove} onUp={handleUp} onDeleteShape={handleDeleteShape} svgRef={svgRef} marquee={marquee} />;
        };

        const LayoutCanvas = ({ viewState, setViewState, assets, instances, setInstances, selectedIds, setSelectedIds }) => {
            const dragRef = useRef({ isDragging: false, mode: null });
            const svgRef = useRef(null);
            const [marquee, setMarquee] = useState(null); // { sx, sy, ex, ey } ÁîªÈù¢Â∫ßÊ®ô

            const handleDown = (e, id) => {
                // Â∑¶„ÇØ„É™„ÉÉ„ÇØ‰ª•Â§ñ„ÅØÁÑ°Ë¶ñÔºà‰∏≠„ÇØ„É™„ÉÉ„ÇØ„ÅØ‰æãÂ§ñ„Åß„Éë„É≥Áî®Ôºâ
                if (e.button !== 0 && e.button !== 1) return;

                // „Éù„Ç§„É≥„Çø„Éº„Ç≠„É£„Éó„ÉÅ„É£„ÇíË®≠ÂÆöÔºàÂøÖ„ÅöË¶™div„ÅßÊçïÊçâÔºâ
                if (svgRef.current && e.pointerId) {
                    try { svgRef.current.setPointerCapture(e.pointerId); } catch (err) { /* ignore */ }
                }

                // ‰∏≠„ÇØ„É™„ÉÉ„ÇØ„ÅÆ„Åø„Éë„É≥„ÄÅËÉåÊôØÂ∑¶„ÇØ„É™„ÉÉ„ÇØ„ÅØ„Éû„Éº„Ç≠„ÉºÈÅ∏Êäû
                const isPan = e.button === 1;
                const isMarquee = (id === null && e.button === 0);

                let targetIds = [];
                if (id) {
                    if (e.ctrlKey || e.metaKey) {
                        // Ctrl+„ÇØ„É™„ÉÉ„ÇØ: ÈÅ∏Êäû„Å´„Éà„Ç∞„É´
                        if (selectedIds.includes(id)) {
                            targetIds = selectedIds.filter(x => x !== id);
                        } else {
                            targetIds = [...selectedIds, id];
                        }
                        setSelectedIds(targetIds);
                    } else if (selectedIds.includes(id)) {
                        // Êó¢„Å´ÈÅ∏Êäû‰∏≠„ÅÆ„Ç¢„Ç§„ÉÜ„É†„Çí„ÇØ„É™„ÉÉ„ÇØ: ÈÅ∏ÊäûÁ∂≠ÊåÅ
                        targetIds = [...selectedIds];
                    } else {
                        // ÈÄöÂ∏∏„ÇØ„É™„ÉÉ„ÇØ: Âçò‰∏ÄÈÅ∏Êäû
                        targetIds = [id];
                        setSelectedIds([id]);
                    }
                } else if (!isMarquee) {
                    // ËÉåÊôØ„ÇØ„É™„ÉÉ„ÇØÊôÇÔºà„Éû„Éº„Ç≠„Éº‰ª•Â§ñÔºâ„ÅØÈÅ∏Êäû„ÇíËß£Èô§
                    setSelectedIds([]);
                }

                // „Éû„Éº„Ç≠„ÉºÈÅ∏ÊäûÈñãÂßã
                if (isMarquee) {
                    setMarquee({ sx: e.clientX, sy: e.clientY, ex: e.clientX, ey: e.clientY });
                    if (!e.ctrlKey && !e.metaKey) {
                        setSelectedIds([]); // CtrlÊäº„Åó„Å¶„ÅÑ„Å™„Åë„Çå„Å∞ÈÅ∏ÊäûËß£Èô§
                    }
                }

                dragRef.current = {
                    isDragging: true,
                    mode: isPan ? 'panning' : (isMarquee ? 'marquee' : (id ? 'dragging' : null)),
                    sx: e.clientX, sy: e.clientY,
                    vx: viewState.x, vy: viewState.y,
                    items: instances.map(i => ({ ...i })),
                    targetIds: targetIds,
                    prevSelectedIds: e.ctrlKey || e.metaKey ? [...selectedIds] : []
                };

                if (!isPan && id) {
                    // „Ç¢„Ç§„ÉÜ„É†„Éâ„É©„ÉÉ„Ç∞ - „É≠„ÉÉ„ÇØÁä∂ÊÖã„Çí„ÉÅ„Çß„ÉÉ„ÇØ
                    const hasUnlocked = targetIds.some(tid => {
                        const t = instances.find(i => i.id === tid);
                        return t && !t.locked;
                    });
                    if (!hasUnlocked) {
                        dragRef.current.isDragging = false;
                        dragRef.current.mode = null;
                    }
                }

                // „Ç¢„Ç§„ÉÜ„É†‰∏ä„Åß„ÅÆ„Ç§„Éô„É≥„Éà„ÅØËÉåÊôØ„Å´‰ºùÊí≠„Åï„Åõ„Å™„ÅÑ
                if (id) {
                    e.stopPropagation();
                }
                e.preventDefault();
            };
            const handleMove = (e) => {
                if (!dragRef.current.isDragging) return;
                e.preventDefault();
                const dx = e.clientX - dragRef.current.sx;
                const dy = e.clientY - dragRef.current.sy;
                if (dragRef.current.mode === 'panning') {
                    setViewState(p => ({ ...p, x: dragRef.current.vx + dx, y: dragRef.current.vy + dy }));
                } else if (dragRef.current.mode === 'marquee') {
                    // „Éû„Éº„Ç≠„ÉºÁü©ÂΩ¢„ÇíÊõ¥Êñ∞
                    setMarquee(prev => prev ? { ...prev, ex: e.clientX, ey: e.clientY } : null);

                    // „Éû„Éº„Ç≠„ÉºÁü©ÂΩ¢ÂÜÖ„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÇíÈÅ∏Êäû
                    if (svgRef.current) {
                        const rect = svgRef.current.getBoundingClientRect();
                        const scale = viewState.scale * BASE_SCALE;

                        // ÁîªÈù¢Â∫ßÊ®ô„Åã„Çâ„ÉØ„Éº„É´„ÉâÂ∫ßÊ®ô„Å´Â§âÊèõ
                        const toWorld = (screenX, screenY) => ({
                            x: (screenX - rect.left - viewState.x) / scale,
                            y: (screenY - rect.top - viewState.y) / scale
                        });

                        const p1 = toWorld(dragRef.current.sx, dragRef.current.sy);
                        const p2 = toWorld(e.clientX, e.clientY);
                        const minX = Math.min(p1.x, p2.x);
                        const maxX = Math.max(p1.x, p2.x);
                        const minY = Math.min(p1.y, p2.y);
                        const maxY = Math.max(p1.y, p2.y);

                        // Áü©ÂΩ¢ÂÜÖ„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„ÇíÊ§úÂá∫
                        const inBox = instances.filter(inst => {
                            const asset = assets.find(a => a.id === inst.assetId);
                            const w = inst.type === 'text' ? 100 : (asset?.w || 0);
                            const h = inst.type === 'text' ? 50 : (asset?.h || 0);
                            // „Ç¢„Ç§„ÉÜ„É†„ÅÆ‰∏≠ÂøÉ„Åå„Éû„Éº„Ç≠„ÉºÂÜÖ„Å´„ÅÇ„Çã„Åã
                            const cx = inst.x + w / 2;
                            const cy = inst.y + h / 2;
                            return cx >= minX && cx <= maxX && cy >= minY && cy <= maxY;
                        }).map(i => i.id);

                        // CtrlÊäº„Åó„Å¶„ÇãÂ†¥Âêà„ÅØËøΩÂä†ÈÅ∏Êäû
                        const newIds = [...new Set([...dragRef.current.prevSelectedIds, ...inBox])];
                        setSelectedIds(newIds);
                    }
                } else if (dragRef.current.mode === 'dragging') {
                    const wDx = dx / viewState.scale / BASE_SCALE;
                    const wDy = dy / viewState.scale / BASE_SCALE;

                    setInstances(prev => prev.map(inst => {
                        if (dragRef.current.targetIds?.includes(inst.id) && !inst.locked) {
                            const org = dragRef.current.items.find(i => i.id === inst.id);
                            if (!org) return inst;
                            const asset = assets.find(a => a.id === inst.assetId);
                            let nx = org.x + wDx;
                            let ny = org.y + wDy;
                            if (inst.type !== 'text' && asset?.snap && inst.rotation % 90 === 0 && !e.shiftKey) {
                                nx = Math.round(nx / SNAP_UNIT) * SNAP_UNIT;
                                ny = Math.round(ny / SNAP_UNIT) * SNAP_UNIT;
                            }
                            return { ...inst, x: nx, y: ny };
                        }
                        return inst;
                    }));
                }
            };
            const handleUp = () => {
                setMarquee(null);
                dragRef.current = { isDragging: false, mode: null, targetIds: [] };
            };

            const sortedItems = useMemo(() => {
                return instances.map(inst => {
                    if (inst.type === 'text') return { ...inst, z: 99 };
                    const asset = assets.find(a => a.id === inst.assetId);
                    // id „ÅØ inst.id „ÇíÁ∂≠ÊåÅÔºàasset.id „Åß‰∏äÊõ∏„Åç„Åï„Çå„Å™„ÅÑ„Çà„ÅÜÊòéÁ§∫ÁöÑ„Å´ÊåáÂÆöÔºâ
                    return asset ? { ...inst, ...asset, id: inst.id, z: LAYERS[asset.type] } : null;
                }).filter(Boolean).sort((a, b) => {
                    // ÈÅ∏Êäû„Ç¢„Ç§„ÉÜ„É†„ÇíÊúÄÂâçÈù¢„Å´
                    const aSelected = selectedIds.includes(a.id) ? 1000 : 0;
                    const bSelected = selectedIds.includes(b.id) ? 1000 : 0;
                    return (a.z + aSelected) - (b.z + bSelected);
                });
            }, [instances, assets, selectedIds]);

            return (
                <div className="w-full h-full absolute top-0 left-0 z-20 overflow-auto canvas-scroll pt-5 pl-5" onPointerDown={e => handleDown(e, null)} onPointerMove={handleMove} onPointerUp={handleUp} ref={svgRef}>
                    <svg width="3000" height="3000" style={{ minWidth: '3000px', minHeight: '3000px' }}>
                        <g transform={`translate(${viewState.x}, ${viewState.y}) scale(${viewState.scale})`}>
                            <line x1="-5000" y1="0" x2="5000" y2="0" stroke="#ddd" strokeWidth="2" />
                            <line x1="0" y1="-5000" x2="0" y2="5000" stroke="#ddd" strokeWidth="2" />
                            {sortedItems.map(item => <RenderItem key={item.id} item={item} isSelected={selectedIds.includes(item.id)} onDown={handleDown} />)}
                        </g>
                    </svg>
                    {/* „Éû„Éº„Ç≠„ÉºÈÅ∏ÊäûÁü©ÂΩ¢ */}
                    {marquee && (
                        <div
                            style={{
                                position: 'fixed',
                                left: Math.min(marquee.sx, marquee.ex),
                                top: Math.min(marquee.sy, marquee.ey),
                                width: Math.abs(marquee.ex - marquee.sx),
                                height: Math.abs(marquee.ey - marquee.sy),
                                border: '2px dashed #3b82f6',
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                pointerEvents: 'none',
                                zIndex: 9999
                            }}
                        />
                    )}
                </div>
            );
        };

        // --- Sidebars & Properties Panels ---

        const UnifiedSidebar = ({ mode, assets, onAddInstance, onAddText, setLocalAssets, setGlobalAssets, setDesignTargetId, designTargetId, instances, setInstances }) => {
            // Â∏∏„Å´„É≠„Éº„Ç´„É´„Ç¢„Çª„ÉÉ„Éà„ÅÆ„ÅøË°®Á§∫Ôºàglobal„ÅØ„Éó„É≠„Ç∏„Çß„ÇØ„ÉàË™≠ËæºÊôÇ„Å´Ëá™Âãï„Éï„Ç©„Éº„ÇØÊ∏à„ÅøÔºâ
            const filteredAssets = assets.filter(a => !a.source || a.source !== 'global');

            // Êñ∞Ë¶è‰ΩúÊàê (Design ModeÁî®)
            const addNewAsset = () => {
                const initialShape = {
                    type: 'polygon',
                    points: createRectPath(60, 60, 0, 0),
                    color: '#cccccc'
                };
                const newA = {
                    id: `a-${Date.now()}`, name: 'Êñ∞Ë¶è„Éë„Éº„ÉÑ', type: 'room',
                    w: 60, h: 60, color: '#cccccc', snap: true,
                    shapes: [initialShape]
                };
                setLocalAssets(prev => [...prev, newA]);
                setDesignTargetId(newA.id);
            };

            const handleClick = (asset) => {
                if (mode === 'layout') {
                    onAddInstance(asset.id);
                } else {
                    setDesignTargetId(asset.id);
                }
            };

            const deleteAsset = (e, assetId, isGlobal) => {
                e.stopPropagation();
                const usageCount = instances.filter(inst => inst.assetId === assetId).length;
                const message = usageCount > 0
                    ? `„Åì„ÅÆ„Ç¢„Çª„ÉÉ„Éà„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü\nÈÖçÁΩÆÊ∏à„Åø: ${usageCount}ÂÄã„ÅåÂâäÈô§„Åï„Çå„Åæ„Åô„ÄÇ`
                    : '„Åì„ÅÆ„Ç¢„Çª„ÉÉ„Éà„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü';
                if (!confirm(message)) return;

                if (isGlobal) {
                    setGlobalAssets(prev => prev.filter(a => a.id !== assetId));
                } else {
                    setLocalAssets(prev => prev.filter(a => a.id !== assetId));
                }
                setInstances(prev => prev.filter(inst => inst.assetId !== assetId));
                if (designTargetId === assetId) {
                    setDesignTargetId(null);
                }
            };

            return (
                <div className="flex flex-col h-full bg-white">
                    {/* Header Action Area */}
                    <div className="p-3 pb-0">
                        {mode === 'layout' ? (
                            <button onClick={onAddText} className="w-full py-2 bg-yellow-50 border border-yellow-200 text-yellow-800 rounded font-bold mb-2 flex items-center justify-center gap-2 hover:bg-yellow-100 transition text-xs"><Icon p={Icons.Type} /> ÊñáÂ≠ó„ÇíËøΩÂä†</button>
                        ) : (
                            <button onClick={addNewAsset} className="w-full py-2 bg-white border border-dashed border-orange-300 rounded text-orange-600 hover:bg-orange-50 font-bold text-xs">+ Êñ∞Ë¶è„Éë„Éº„ÉÑ</button>
                        )}
                    </div>

                    {/* Asset List (Grid) */}
                    <div className="flex-1 overflow-y-auto p-3">
                        {['room', 'fixture', 'furniture'].map(type => {
                            const typeAssets = filteredAssets.filter(a => a.type === type);
                            if (typeAssets.length === 0) return null;
                            const label = type === 'room' ? 'ÈÉ®Â±ã' : type === 'fixture' ? 'Ë®≠ÂÇô' : 'ÂÆ∂ÂÖ∑';
                            return (
                                <div key={type} className="mb-6">
                                    <div className="text-xs font-bold text-gray-400 mb-2 px-1 border-b pb-1 flex items-center gap-2">{label}</div>
                                    <div className="grid grid-cols-2 gap-2">
                                        {typeAssets.map(a => {
                                            const isSelected = mode === 'design' && designTargetId === a.id;
                                            return (
                                                <button key={a.id} onClick={() => handleClick(a)}
                                                    className={`flex flex-col items-center p-2 border rounded hover:bg-gray-50 text-center relative group transition
                                                        ${a.source === 'global' ? 'bg-blue-50/30 border-blue-100' : ''}
                                                        ${isSelected ? 'ring-2 ring-orange-400 bg-orange-50' : ''}
                                                    `}>
                                                    {a.source === 'global' && <div className="absolute top-1 right-1 text-blue-400"><Icon p={Icons.Globe} size={10} /></div>}
                                                    <div className="w-8 h-8 rounded mb-2 border shadow-sm flex items-center justify-center" style={{ backgroundColor: a.color }}></div>
                                                    <span className="text-[10px] w-full truncate font-medium text-gray-600">{a.name}</span>

                                                    {/* Delete Button (Only visible in Design Mode or for cleanup) */}
                                                    {mode === 'design' && (
                                                        <div
                                                            onClick={(e) => deleteAsset(e, a.id, a.source === 'global')}
                                                            className="absolute top-1 left-1 opacity-0 group-hover:opacity-100 text-gray-300 hover:text-red-500 p-1 transition"
                                                        >
                                                            <Icon p={Icons.Trash} size={12} />
                                                        </div>
                                                    )}
                                                </button>
                                            );
                                        })}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        };

        const LayoutProperties = ({ instances, setInstances, selectedIds, assets, setSelectedIds, setMode, setDesignTargetId }) => {
            const item = instances.find(i => i.id === selectedIds[0]);

            // Êú™ÈÅ∏ÊäûÊôÇ„ÅØÁ∞°Êòì„É™„Çπ„ÉàË°®Á§∫
            if (!item) {
                return (
                    <div className="h-full flex flex-col text-gray-500 text-xs items-center justify-center p-4">
                        <Icon p={Icons.Move} size={48} className="text-gray-200 mb-2" />
                        <p>„Ç≠„É£„É≥„Éê„Çπ‰∏ä„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÇíÈÅ∏Êäû„Åô„Çã„Å®<br />Ë©≥Á¥∞Ë®≠ÂÆö„ÅåË°®Á§∫„Åï„Çå„Åæ„Åô</p>
                        <div className="mt-8 w-full border-t pt-4">
                            <p className="font-bold text-gray-400 mb-2 text-left w-full">ÈÖçÁΩÆÊ∏à„Åø ({instances.length})</p>
                            <div className="space-y-1 max-h-60 overflow-y-auto w-full text-left">
                                {instances.map(inst => {
                                    const a = assets.find(x => x.id === inst.assetId);
                                    return (
                                        <div key={inst.id} onClick={() => setSelectedIds([inst.id])} className="p-2 border rounded hover:bg-gray-50 cursor-pointer flex items-center justify-between">
                                            <span className="truncate">{a ? a.name : inst.text}</span>
                                            <span className="text-[10px] text-gray-300">{inst.id.slice(-4)}</span>
                                        </div>
                                    )
                                })}
                            </div>
                        </div>
                    </div>
                );
            }

            const update = (k, v) => setInstances(p => p.map(i => i.id === item.id ? { ...i, [k]: v } : i));

            // ÂÖ®‰Ωì„Çí0,0„Å´ÊèÉ„Åà„ÇãÊ©üËÉΩÔºà„Åô„Åπ„Å¶„ÅÆ„Ç§„É≥„Çπ„Çø„É≥„Çπ„Çí„Ç∞„É´„Éº„Éó„Å®„Åó„Å¶ÁßªÂãïÔºâ
            const alignToOrigin = () => {
                if (instances.length === 0) return;
                const minX = Math.min(...instances.map(i => i.x));
                const minY = Math.min(...instances.map(i => i.y));
                if (minX === 0 && minY === 0) return;
                setInstances(prev => prev.map(i => ({
                    ...i,
                    x: i.x - minX,
                    y: i.y - minY
                })));
            };

            const asset = assets.find(a => a.id === item.assetId);

            // Ë§áÊï∞ÈÅ∏ÊäûÊôÇ„ÅÆË°®Á§∫
            const multiSelected = selectedIds.length > 1;

            // ÈÅ∏Êäû„Ç¢„Ç§„ÉÜ„É†„Çí0,0„Å´ÊèÉ„Åà„ÇãÔºàË§áÊï∞ÈÅ∏ÊäûÂØæÂøúÔºâ
            const alignSelectedToOrigin = () => {
                const targets = instances.filter(i => selectedIds.includes(i.id));
                if (targets.length === 0) return;
                const minX = Math.min(...targets.map(i => i.x));
                const minY = Math.min(...targets.map(i => i.y));
                if (minX === 0 && minY === 0) return;
                setInstances(prev => prev.map(i => {
                    if (selectedIds.includes(i.id)) {
                        return { ...i, x: i.x - minX, y: i.y - minY };
                    }
                    return i;
                }));
            };

            // ÈÅ∏Êäû„Ç¢„Ç§„ÉÜ„É†„Çí‰∏ÄÊã¨ÂâäÈô§
            const deleteSelected = () => {
                if (!confirm(`ÈÅ∏Êäû„Åó„Åü ${selectedIds.length} ÂÄã„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`)) return;
                setInstances(prev => prev.filter(i => !selectedIds.includes(i.id)));
                setSelectedIds([]);
            };

            return (
                <div className="h-full flex flex-col">
                    <div className="sidebar-header">
                        <span>{multiSelected ? `${selectedIds.length}ÂÄãÈÅ∏Êäû‰∏≠` : 'ÈÖçÁΩÆ„Éó„É≠„Éë„ÉÜ„Ç£'}</span>
                        <button onClick={multiSelected ? alignSelectedToOrigin : alignToOrigin} className="text-[10px] bg-blue-50 text-blue-600 px-2 py-1 rounded border border-blue-200 hover:bg-blue-100">
                            0,0„Å∏ÁßªÂãï
                        </button>
                    </div>

                    <div className="p-3 overflow-y-auto flex-1">
                        {/* Ë§áÊï∞ÈÅ∏ÊäûÊôÇ */}
                        {multiSelected ? (
                            <div className="space-y-4">
                                <div className="bg-purple-50 border border-purple-100 rounded p-3">
                                    <div className="font-bold text-sm text-purple-800 mb-2">{selectedIds.length} ÂÄã„ÅÆ„Ç¢„Ç§„ÉÜ„É†„ÇíÈÅ∏Êäû‰∏≠</div>
                                    <div className="text-[10px] text-purple-500">Ctrl+„ÇØ„É™„ÉÉ„ÇØ„ÅßÈÅ∏Êäû„ÇíË™øÊï¥</div>
                                </div>
                                <div className="space-y-2">
                                    <button
                                        onClick={alignSelectedToOrigin}
                                        className="btn-action bg-blue-500 text-white hover:bg-blue-600 shadow-sm"
                                    >
                                        <Icon p={Icons.Move} size={14} /> ÈÅ∏Êäû„Çí0,0„Å∏ÊèÉ„Åà„Çã
                                    </button>
                                    <button
                                        onClick={deleteSelected}
                                        className="btn-action bg-red-500 text-white hover:bg-red-600 shadow-sm"
                                    >
                                        <Icon p={Icons.Trash} size={14} /> ÈÅ∏Êäû„ÇíÂâäÈô§
                                    </button>
                                    <button
                                        onClick={() => setSelectedIds([])}
                                        className="btn-action bg-gray-100 text-gray-600 hover:bg-gray-200"
                                    >
                                        ÈÅ∏ÊäûËß£Èô§
                                    </button>
                                </div>
                                <div className="border-t pt-3">
                                    <div className="text-xs font-bold text-gray-400 mb-2">ÈÅ∏Êäû‰∏≠„ÅÆ„Ç¢„Ç§„ÉÜ„É†</div>
                                    <div className="space-y-1 max-h-40 overflow-y-auto">
                                        {selectedIds.map(id => {
                                            const inst = instances.find(i => i.id === id);
                                            const a = inst ? assets.find(x => x.id === inst.assetId) : null;
                                            return (
                                                <div key={id} className="text-xs p-2 bg-gray-50 rounded flex items-center justify-between">
                                                    <span className="truncate">{a?.name || inst?.text || '„ÉÜ„Ç≠„Çπ„Éà'}</span>
                                                    <button onClick={() => setSelectedIds(prev => prev.filter(x => x !== id))} className="text-gray-300 hover:text-red-500">√ó</button>
                                                </div>
                                            );
                                        })}
                                    </div>
                                </div>
                            </div>
                        ) : (
                            <>
                                {/* Selected Item Info */}
                                <div className="bg-blue-50 border border-blue-100 rounded p-3 mb-4">
                                    <div className="font-bold text-sm text-blue-800 mb-1">{item.type === 'text' ? '„ÉÜ„Ç≠„Çπ„Éà' : asset?.name}</div>
                                    <div className="text-[10px] text-blue-400 font-mono">{item.id}</div>
                                </div>

                                {/* Actions */}
                                {item.type !== 'text' && (
                                    <button
                                        onClick={() => {
                                            setDesignTargetId(item.assetId);
                                            setMode('design');
                                        }}
                                        className="btn-action bg-orange-500 text-white hover:bg-orange-600 mb-4 shadow-sm"
                                    >
                                        <Icon p={Icons.Pen} size={14} /> ÂΩ¢Áä∂„ÇíÁ∑®ÈõÜ (Ë®≠Ë®à„É¢„Éº„Éâ)
                                    </button>
                                )}

                                {/* Coordinates */}
                                <div className="mb-4">
                                    <div className="text-xs font-bold text-gray-400 mb-2 border-b pb-1">Â∫ßÊ®ô„ÉªÂõûËª¢</div>
                                    <div className="prop-row">
                                        <label className="prop-label">X (mm)</label>
                                        <input type="number" value={toMM(item.x)} onChange={e => update('x', fromMM(Number(e.target.value)))} className="prop-input" />
                                    </div>
                                    <div className="prop-row">
                                        <label className="prop-label">Y (mm)</label>
                                        <input type="number" value={toMM(item.y)} onChange={e => update('y', fromMM(Number(e.target.value)))} className="prop-input" />
                                    </div>
                                    <div className="prop-row">
                                        <label className="prop-label">ÂõûËª¢ (¬∞)</label>
                                        <div className="flex-1 flex gap-2">
                                            <input type="number" value={item.rotation} onChange={e => update('rotation', Number(e.target.value))} className="prop-input" />
                                            <button onClick={() => update('rotation', (item.rotation + 90) % 360)} className="px-2 border rounded bg-gray-50 hover:bg-gray-100 text-xs">‚Üª</button>
                                        </div>
                                    </div>
                                </div>

                                {/* Content (Text only) */}
                                {item.type === 'text' && (
                                    <div className="mb-4">
                                        <div className="text-xs font-bold text-gray-400 mb-2 border-b pb-1">„ÉÜ„Ç≠„Çπ„ÉàË®≠ÂÆö</div>
                                        <div className="mb-2">
                                            <label className="prop-label block text-left mb-1">ÂÜÖÂÆπ</label>
                                            <textarea value={item.text} onChange={e => update('text', e.target.value)} className="w-full border rounded p-2 text-sm h-20" />
                                        </div>
                                        <div className="prop-row">
                                            <label className="prop-label">„Çµ„Ç§„Ç∫</label>
                                            <input type="number" value={item.fontSize} onChange={e => update('fontSize', Number(e.target.value))} className="prop-input" />
                                        </div>
                                        <div className="prop-row">
                                            <label className="prop-label">Ëâ≤</label>
                                            <input type="color" value={item.color} onChange={e => update('color', e.target.value)} className="h-8 w-full cursor-pointer" />
                                        </div>
                                    </div>
                                )}

                                {/* Copy / Lock / Delete */}
                                <div className="border-t pt-4 mt-2 space-y-2">
                                    <button onClick={() => {
                                        const newInst = { ...item, id: `${item.type === 'text' ? 't' : 'i'}-${Date.now()}`, x: item.x + 10, y: item.y + 10 };
                                        setInstances(p => [...p, newInst]);
                                        setSelectedIds([newInst.id]);
                                    }} className="btn-action bg-blue-50 border border-blue-200 text-blue-600 hover:bg-blue-100">
                                        <Icon p={Icons.Copy} size={14} /> „Ç≥„Éî„Éº„Åó„Å¶ÈÖçÁΩÆ
                                    </button>
                                    <label className="flex items-center gap-2 p-2 rounded cursor-pointer hover:bg-gray-50 border">
                                        <input type="checkbox" checked={item.locked} onChange={e => update('locked', e.target.checked)} className="accent-blue-600" />
                                        <span className="text-xs font-bold text-gray-600 flex items-center gap-1">
                                            {item.locked ? <Icon p={Icons.Lock} size={12} /> : <Icon p={Icons.Unlock} size={12} />} „É≠„ÉÉ„ÇØ„Åô„Çã
                                        </span>
                                    </label>
                                    <button onClick={() => { setInstances(p => p.filter(i => i.id !== item.id)); setSelectedIds([]); }} className="btn-action bg-white border border-red-200 text-red-500 hover:bg-red-50">
                                        <Icon p={Icons.Trash} size={14} /> ÂâäÈô§
                                    </button>
                                </div>
                            </>
                        )}
                    </div>
                </div>
            );
        };

        const DesignProperties = ({ assets, designTargetId, setLocalAssets, setGlobalAssets, selectedShapeIndices, setSelectedShapeIndices, selectedPointIndex, setSelectedPointIndex, setDesignTargetId, palette, onAddToPalette }) => {
            const asset = assets.find(a => a.id === designTargetId);

            // Êú™ÈÅ∏ÊäûÊôÇ
            if (!asset) {
                return (
                    <div className="h-full flex flex-col text-gray-500 text-xs items-center justify-center p-4">
                        <Icon p={Icons.Pen} size={48} className="text-orange-200 mb-2" />
                        <p>Â∑¶„ÅÆ„É™„Çπ„Éà„Åã„ÇâÁ∑®ÈõÜ„Åô„Çã<br />„Ç¢„Çª„ÉÉ„Éà„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ</p>
                    </div>
                );
            }

            const isMultiSelect = selectedShapeIndices.length > 1;
            const targetIndex = selectedShapeIndices.length === 1 ? selectedShapeIndices[0] : null;
            const selectedShape = (asset.shapes && targetIndex !== null) ? asset.shapes[targetIndex] : null;
            const selectedPoint = (selectedShape && selectedShape.points && selectedPointIndex !== null) ? selectedShape.points[selectedPointIndex] : null;

            const updateRoot = (k, v) => { if (asset.source === 'global') return; setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, [k]: v } : a)); };

            // Âçò‰∏ÄÈÅ∏ÊäûÁî®Êõ¥Êñ∞Èñ¢Êï∞
            const updateShape = (k, v) => {
                if (asset.source === 'global' || targetIndex === null) return;
                const currentShapes = asset.shapes || [];
                const newShapes = currentShapes.map((s, i) => i === targetIndex ? { ...s, [k]: v } : s);
                setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
            };
            const updatePoint = (k, v) => {
                if (asset.source === 'global' || targetIndex === null || selectedPointIndex === null) return;
                const newShapes = [...asset.shapes];
                const newPts = [...newShapes[targetIndex].points];
                const newPt = { ...newPts[selectedPointIndex], [k]: v };
                newPts[selectedPointIndex] = newPt;
                newShapes[targetIndex].points = newPts;
                setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
            };

            // ‰∏ÄÊã¨Êìç‰ΩúÁî®Èñ¢Êï∞
            const bulkUpdate = (updater) => {
                const newShapes = asset.shapes.map((s, i) => {
                    if (selectedShapeIndices.includes(i)) {
                        return updater(s);
                    }
                    return s;
                });
                setLocalAssets(prev => prev.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
            };

            const bulkMove = (dx, dy) => {
                bulkUpdate(s => {
                    let ns = { ...s, x: (s.x || 0) + dx, y: (s.y || 0) + dy };
                    if (s.cx !== undefined) ns.cx = (s.cx || 0) + dx;
                    if (s.cy !== undefined) ns.cy = (s.cy || 0) + dy;
                    if (s.points) ns.points = s.points.map(p => ({ ...p, x: p.x + dx, y: p.y + dy }));
                    return ns;
                });
            };

            const bulkDelete = () => {
                if (!confirm(`${selectedShapeIndices.length}ÂÄã„ÅÆ„Ç∑„Çß„Ç§„Éó„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`)) return;
                const newShapes = asset.shapes.filter((_, i) => !selectedShapeIndices.includes(i));
                setLocalAssets(prev => prev.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                setSelectedShapeIndices([]);
            };

            const bulkColor = (color) => {
                bulkUpdate(s => ({ ...s, color }));
            };

            const bulkResize = (scalePercent) => {
                const scale = scalePercent / 100;
                if (scale <= 0) return;

                // 1. „Ç∞„É´„Éº„Éó„ÅÆ„Éê„Ç¶„É≥„Éá„Ç£„É≥„Ç∞„Éú„ÉÉ„ÇØ„ÇπÔºàÂ∑¶‰∏äÔºâ„ÇíË®àÁÆó
                let groupMinX = Infinity;
                let groupMinY = Infinity;

                selectedShapeIndices.forEach(index => {
                    const s = asset.shapes[index];
                    if (!s) return;
                    if (s.points) {
                        s.points.forEach(p => {
                            if (p.x < groupMinX) groupMinX = p.x;
                            if (p.y < groupMinY) groupMinY = p.y;
                        });
                    } else if (s.type === 'ellipse' || s.type === 'arc' || s.type === 'circle') {
                        const cx = s.cx !== undefined ? s.cx : (s.x + s.w / 2);
                        const cy = s.cy !== undefined ? s.cy : (s.y + s.h / 2);
                        const rx = s.rx !== undefined ? s.rx : (s.w / 2);
                        const ry = s.ry !== undefined ? s.ry : (s.h / 2);
                        if (cx - rx < groupMinX) groupMinX = cx - rx;
                        if (cy - ry < groupMinY) groupMinY = cy - ry;
                    } else {
                        const x = s.x || 0;
                        const y = s.y || 0;
                        if (x < groupMinX) groupMinX = x;
                        if (y < groupMinY) groupMinY = y;
                    }
                });

                if (groupMinX === Infinity || groupMinY === Infinity) return;

                // 2. Â∑¶‰∏äÂü∫Ê∫ñ„Åß„Çπ„Ç±„Éº„É™„É≥„Ç∞
                bulkUpdate(s => {
                    let ns = { ...s };

                    if (s.points) {
                        ns.points = s.points.map(p => ({
                            ...p,
                            x: Math.round(groupMinX + (p.x - groupMinX) * scale),
                            y: Math.round(groupMinY + (p.y - groupMinY) * scale)
                        }));
                        // width/heightÂÜçË®àÁÆó (PolygonÁî®)
                        const xs = ns.points.map(p => p.x);
                        const ys = ns.points.map(p => p.y);
                        ns.w = Math.max(...xs) - Math.min(...xs);
                        ns.h = Math.max(...ys) - Math.min(...ys);
                        // x, y „ÇÇÊõ¥Êñ∞„Åô„ÇãÂ†¥Âêà„Åå„ÅÇ„Çã„Åå„ÄÅpoints„É°„Ç§„É≥„Å™„ÇâÂÜçË®àÁÆó‰∏çË¶Å„Åã„ÇÇ„Åó„Çå„Å™„ÅÑ„Åå‰∏ÄÂøúÊõ¥Êñ∞
                        ns.x = Math.min(...xs);
                        ns.y = Math.min(...ys);

                    } else if (s.type === 'ellipse' || s.type === 'arc' || s.type === 'circle') {
                        const cx = s.cx !== undefined ? s.cx : (s.x + s.w / 2);
                        const cy = s.cy !== undefined ? s.cy : (s.y + s.h / 2);
                        const rx = s.rx !== undefined ? s.rx : (s.w / 2);
                        const ry = s.ry !== undefined ? s.ry : (s.h / 2);

                        const newCx = groupMinX + (cx - groupMinX) * scale;
                        const newCy = groupMinY + (cy - groupMinY) * scale;
                        const newRx = rx * scale;
                        const newRy = ry * scale;

                        if (s.cx !== undefined) ns.cx = Math.round(newCx);
                        if (s.cy !== undefined) ns.cy = Math.round(newCy);
                        if (s.rx !== undefined) ns.rx = Math.round(newRx);
                        if (s.ry !== undefined) ns.ry = Math.round(newRy);
                        // x, y, w, h „ÇÇÊõ¥Êñ∞
                        ns.x = Math.round(newCx - newRx);
                        ns.y = Math.round(newCy - newRy);
                        ns.w = Math.round(newRx * 2);
                        ns.h = Math.round(newRy * 2);

                    } else {
                        // Rect / Image / Text etc
                        // position
                        const x = s.x || 0;
                        const y = s.y || 0;
                        const newX = groupMinX + (x - groupMinX) * scale;
                        const newY = groupMinY + (y - groupMinY) * scale;

                        ns.x = Math.round(newX);
                        ns.y = Math.round(newY);
                        if (s.w) ns.w = Math.round(s.w * scale);
                        if (s.h) ns.h = Math.round(s.h * scale);
                    }

                    return ns;
                });
            };

            const fork = () => {
                const newId = `a-fork-${Date.now()}`;
                const newA = { ...asset, id: newId, name: asset.name + ' („Ç≥„Éî„Éº)', source: undefined };
                setLocalAssets(prev => [...prev, newA]);
                if (setDesignTargetId) setDesignTargetId(newId);
            };
            const publish = () => { if (!confirm('ÂÖ±ÈÄö„É©„Ç§„Éñ„É©„É™„Å´ËøΩÂä†„Åó„Åæ„Åô„ÅãÔºü')) return; setGlobalAssets(prev => [...prev, { ...asset, id: `a-pub-${Date.now()}`, source: undefined }]); alert('ËøΩÂä†„Åó„Åæ„Åó„Åü'); };

            // ÂÖ®‰Ωì„Çí(0,0)„Å´ÂØÑ„Åõ„Çã
            const normalizePosition = () => {
                if (asset.source === 'global') return;
                const shapes = asset.shapes || [];
                if (shapes.length === 0) return;
                let minX = Infinity, minY = Infinity;
                shapes.forEach(s => {
                    if (s.points) {
                        s.points.forEach(p => { minX = Math.min(minX, p.x); minY = Math.min(minY, p.y); });
                    } else {
                        minX = Math.min(minX, s.x || 0); minY = Math.min(minY, s.y || 0);
                    }
                });
                if (minX === Infinity || (minX === 0 && minY === 0)) return;
                const newShapes = shapes.map(s => {
                    if (s.points) return { ...s, points: s.points.map(p => ({ ...p, x: p.x - minX, y: p.y - minY })) };
                    return { ...s, x: (s.x || 0) - minX, y: (s.y || 0) - minY };
                });
                let maxX = 0, maxY = 0;
                newShapes.forEach(s => {
                    if (s.points) s.points.forEach(p => { maxX = Math.max(maxX, p.x); maxY = Math.max(maxY, p.y); });
                    else { maxX = Math.max(maxX, (s.x || 0) + s.w); maxY = Math.max(maxY, (s.y || 0) + s.h); }
                });
                setLocalAssets(prev => prev.map(a => a.id === designTargetId ? { ...a, shapes: newShapes, w: maxX, h: maxY } : a));
            };

            if (asset.source === 'global') return (
                <div className="p-4 bg-blue-50 h-full flex flex-col items-center justify-center text-center">
                    <Icon p={Icons.Lock} size={32} className="text-blue-300 mb-2" />
                    <div className="text-sm font-bold text-blue-800 mb-1">{asset.name}</div>
                    <div className="text-xs text-blue-600 mb-4">ÂÖ±ÈÄö„Éë„Éº„ÉÑ„ÅØÁ∑®ÈõÜ„Åß„Åç„Åæ„Åõ„Çì</div>
                    <button onClick={fork} className="bg-blue-600 text-white text-xs px-4 py-2 rounded shadow hover:bg-blue-700 flex items-center gap-2"><Icon p={Icons.Copy} size={14} /> „Ç≥„Éî„Éº„Åó„Å¶Á∑®ÈõÜ</button>
                </div>
            );

            return (
                <div className="h-full flex flex-col">
                    <div className="sidebar-header">
                        <span>ÂΩ¢Áä∂„Éó„É≠„Éë„ÉÜ„Ç£</span>
                        <button onClick={normalizePosition} className="text-[10px] bg-orange-50 text-orange-600 px-2 py-1 rounded border border-orange-200 hover:bg-orange-100">
                            0,0„Å´ÊèÉ„Åà„Çã
                        </button>
                    </div>

                    <div className="p-3 overflow-y-auto flex-1 space-y-4">
                        {/* Basic Info */}
                        <div className="bg-orange-50 border border-orange-100 rounded p-2">
                            <div className="prop-row">
                                <label className="prop-label">ÂêçÁß∞</label>
                                <input value={asset.name} onChange={e => updateRoot('name', e.target.value)} className="prop-input font-bold text-left" />
                            </div>
                            <div className="prop-row">
                                <label className="prop-label">Á®ÆÈ°û</label>
                                <select value={asset.type} onChange={e => updateRoot('type', e.target.value)} className="prop-input text-xs">
                                    <option value="room">ÈÉ®Â±ã„ÉªÂ∫ä</option>
                                    <option value="fixture">Ë®≠ÂÇô„ÉªÂª∫ÂÖ∑</option>
                                    <option value="furniture">ÂÆ∂ÂÖ∑</option>
                                </select>
                            </div>
                            <div className="pt-2">
                                <label className="prop-label block mb-1">ÂÖ®‰ΩìËâ≤</label>
                                <ColorPicker value={asset.color} onChange={c => updateRoot('color', c)} palette={palette} onAddToPalette={onAddToPalette} />
                            </div>
                        </div>

                        {/* Shape / Point Editor */}
                        {isMultiSelect ? (
                            <div className="bg-purple-50 border border-purple-100 rounded p-3 space-y-3">
                                <div className="font-bold text-sm text-purple-800">{selectedShapeIndices.length} ÂÄã„ÅÆ„Ç∑„Çß„Ç§„Éó„ÇíÈÅ∏Êäû‰∏≠</div>
                                <div className="text-[10px] text-purple-500">‰∏ÄÊã¨Êìç‰Ωú</div>

                                {/* ‰∏ÄÊã¨ÁßªÂãï */}
                                <div className="prop-row">
                                    <label className="prop-label">ÁßªÂãï (mm)</label>
                                    <div className="flex gap-1">
                                        <button onClick={() => bulkMove(-100, 0)} className="px-2 py-1 bg-white rounded border hover:bg-gray-50">‚Üê</button>
                                        <button onClick={() => bulkMove(0, -100)} className="px-2 py-1 bg-white rounded border hover:bg-gray-50">‚Üë</button>
                                        <button onClick={() => bulkMove(0, 100)} className="px-2 py-1 bg-white rounded border hover:bg-gray-50">‚Üì</button>
                                        <button onClick={() => bulkMove(100, 0)} className="px-2 py-1 bg-white rounded border hover:bg-gray-50">‚Üí</button>
                                    </div>
                                </div>

                                {/* ‰∏ÄÊã¨„É™„Çµ„Ç§„Ç∫ */}
                                <div className="prop-row">
                                    <label className="prop-label">Êã°Â§ßÁ∏ÆÂ∞è</label>
                                    <div className="flex gap-1">
                                        <button onClick={() => bulkResize(90)} className="px-2 py-1 bg-white rounded border hover:bg-gray-50 text-xs">90%</button>
                                        <button onClick={() => bulkResize(110)} className="px-2 py-1 bg-white rounded border hover:bg-gray-50 text-xs">110%</button>
                                    </div>
                                </div>

                                {/* ‰∏ÄÊã¨Ëâ≤Â§âÊõ¥ */}
                                <div>
                                    <label className="prop-label block mb-1">‰∏ÄÊã¨Ëâ≤Â§âÊõ¥</label>
                                    <ColorPicker value={asset.color} onChange={bulkColor} palette={palette} onAddToPalette={onAddToPalette} />
                                </div>

                                {/* ‰∏ÄÊã¨ÂâäÈô§ */}
                                <button onClick={bulkDelete} className="w-full py-2 bg-red-500 text-white rounded text-xs hover:bg-red-600 shadow-sm mt-2">
                                    ÈÅ∏Êäû„Åó„Åü„Ç∑„Çß„Ç§„Éó„ÇíÂâäÈô§
                                </button>
                                <button
                                    onClick={() => setSelectedShapeIndices([])}
                                    className="w-full py-1 bg-gray-200 text-gray-600 rounded text-xs hover:bg-gray-300 mt-1"
                                >
                                    ÈÅ∏ÊäûËß£Èô§
                                </button>
                            </div>
                        ) : selectedPoint ? (
                            <div className="bg-white p-2 rounded border-2 border-red-300">
                                <div className="text-xs font-bold text-red-600 mb-2">ÈÅ∏ÊäûÈ†ÇÁÇπ (mm)</div>
                                <div className="prop-row">
                                    <label className="prop-label">X</label>
                                    <input type="number" value={toMM(selectedPoint.x)} onChange={e => updatePoint('x', fromMM(Number(e.target.value)))} className="prop-input" />
                                </div>
                                <div className="prop-row">
                                    <label className="prop-label">Y</label>
                                    <input type="number" value={toMM(selectedPoint.y)} onChange={e => updatePoint('y', fromMM(Number(e.target.value)))} className="prop-input" />
                                </div>
                                <div className="mt-2 pt-2 border-t">
                                    <button onClick={() => {
                                        if (selectedShape.points.length <= 3) { alert('ÊúÄ‰Ωé3ÁÇπÂøÖË¶Å„Åß„Åô'); return; }
                                        const newPts = selectedShape.points.filter((_, i) => i !== selectedPointIndex);
                                        const newShapes = [...asset.shapes];
                                        newShapes[targetIndex].points = newPts;
                                        setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                                        setSelectedPointIndex(null);
                                    }} className="w-full py-1.5 text-xs bg-red-50 border border-red-200 text-red-600 rounded hover:bg-red-100 font-bold">„Åì„ÅÆÈ†ÇÁÇπ„ÇíÂâäÈô§</button>
                                </div>
                            </div>
                        ) : selectedShape ? (
                            <div className="bg-white p-2 rounded border-2 border-blue-300">
                                <div className="text-xs font-bold text-blue-600 mb-2">ÈÅ∏Êäû„Éë„Éº„ÉÑ (mm)</div>
                                {selectedShape.type !== 'polygon' && selectedShape.type !== 'ellipse' && (
                                    <>
                                        <div className="prop-row"><label className="prop-label">ÂπÖ</label><input type="number" value={toMM(selectedShape.w)} onChange={e => updateShape('w', fromMM(Number(e.target.value)))} className="prop-input" /></div>
                                        <div className="prop-row"><label className="prop-label">Â••</label><input type="number" value={toMM(selectedShape.h)} onChange={e => updateShape('h', fromMM(Number(e.target.value)))} className="prop-input" /></div>
                                        <div className="prop-row"><label className="prop-label">X</label><input type="number" value={toMM(selectedShape.x || 0)} onChange={e => updateShape('x', fromMM(Number(e.target.value)))} className="prop-input" /></div>
                                        <div className="prop-row"><label className="prop-label">Y</label><input type="number" value={toMM(selectedShape.y || 0)} onChange={e => updateShape('y', fromMM(Number(e.target.value)))} className="prop-input" /></div>
                                    </>
                                )}
                                <div className="pt-2">
                                    <label className="prop-label block mb-1">Ëâ≤</label>
                                    <ColorPicker value={selectedShape.color || asset.color} onChange={c => updateShape('color', c)} palette={palette} onAddToPalette={onAddToPalette} />
                                </div>

                                {/* Ê•ïÂÜÜ„Éó„É≠„Éë„ÉÜ„Ç£ */}
                                {selectedShape.type === 'ellipse' && (
                                    <div className="mt-3 border-t pt-2">
                                        <div className="text-[10px] font-bold text-green-600 mb-2">Ê•ïÂÜÜ„Éó„É≠„Éë„ÉÜ„Ç£</div>
                                        <div className="prop-row"><label className="prop-label">‰∏≠ÂøÉX</label><input type="number" value={toMM(selectedShape.cx || 0)} onChange={e => updateShape('cx', fromMM(Number(e.target.value)))} className="prop-input" /></div>
                                        <div className="prop-row"><label className="prop-label">‰∏≠ÂøÉY</label><input type="number" value={toMM(selectedShape.cy || 0)} onChange={e => updateShape('cy', fromMM(Number(e.target.value)))} className="prop-input" /></div>
                                        <div className="prop-row"><label className="prop-label">Ê®™ÂçäÂæÑ</label><input type="number" value={toMM(selectedShape.rx || 50)} onChange={e => updateShape('rx', fromMM(Number(e.target.value)))} className="prop-input" /></div>
                                        <div className="prop-row"><label className="prop-label">Á∏¶ÂçäÂæÑ</label><input type="number" value={toMM(selectedShape.ry || 50)} onChange={e => updateShape('ry', fromMM(Number(e.target.value)))} className="prop-input" /></div>
                                        <div className="prop-row"><label className="prop-label">ÂõûËª¢¬∞</label><input type="number" value={selectedShape.rotation || 0} onChange={e => updateShape('rotation', Number(e.target.value))} className="prop-input" /></div>
                                        <div className="prop-row"><label className="prop-label">ÈñãÂßãËßí¬∞</label><input type="number" value={selectedShape.startAngle || 0} onChange={e => updateShape('startAngle', Number(e.target.value))} className="prop-input" /></div>
                                        <div className="prop-row"><label className="prop-label">ÁµÇ‰∫ÜËßí¬∞</label><input type="number" value={selectedShape.endAngle || 360} onChange={e => updateShape('endAngle', Number(e.target.value))} className="prop-input" /></div>
                                        <div className="prop-row items-center">
                                            <label className="prop-label">ÂΩ¢Áä∂</label>
                                            <select value={selectedShape.arcMode || 'sector'} onChange={e => updateShape('arcMode', e.target.value)} className="prop-input text-xs">
                                                <option value="sector">ÊâáÂΩ¢</option>
                                                <option value="chord">ÂºìÂΩ¢</option>
                                            </select>
                                        </div>
                                    </div>
                                )}
                                {selectedShape.type === 'polygon' && selectedShape.points && (
                                    <div className="mt-3 border-t pt-2">
                                        <div className="flex justify-between items-center mb-2">
                                            <span className="text-[10px] font-bold text-purple-600">È†ÇÁÇπÁ∑®ÈõÜ ({selectedShape.points.length}ÁÇπ)</span>
                                        </div>
                                        <div className="space-y-0 max-h-48 overflow-y-auto scrollbar-thin">
                                            {selectedShape.points.map((pt, idx) => (
                                                <React.Fragment key={idx}>
                                                    {/* È†ÇÁÇπË°å */}
                                                    <div className={`border rounded p-1.5 ${selectedPointIndex === idx ? 'bg-purple-50 border-purple-300' : 'hover:bg-gray-50'}`}>
                                                        <div className="flex items-center gap-1">
                                                            <span onClick={() => setSelectedPointIndex(idx)} className="w-5 h-5 flex items-center justify-center font-bold text-purple-400 bg-purple-100 rounded cursor-pointer text-[10px]">{idx}</span>
                                                            <input type="number" value={toMM(pt.x)} onChange={e => {
                                                                const newPts = [...selectedShape.points];
                                                                newPts[idx] = { ...newPts[idx], x: fromMM(Number(e.target.value)) };
                                                                const newShapes = [...asset.shapes];
                                                                newShapes[targetIndex].points = newPts;
                                                                setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                                                            }} className="flex-1 text-[10px] p-0.5 border rounded w-12 text-center" placeholder="X" />
                                                            <input type="number" value={toMM(pt.y)} onChange={e => {
                                                                const newPts = [...selectedShape.points];
                                                                newPts[idx] = { ...newPts[idx], y: fromMM(Number(e.target.value)) };
                                                                const newShapes = [...asset.shapes];
                                                                newShapes[targetIndex].points = newPts;
                                                                setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                                                            }} className="flex-1 text-[10px] p-0.5 border rounded w-12 text-center" placeholder="Y" />
                                                            <button onClick={() => {
                                                                if (selectedShape.points.length <= 3) { alert('ÊúÄ‰Ωé3ÁÇπÂøÖË¶Å„Åß„Åô'); return; }
                                                                const newPts = selectedShape.points.filter((_, i) => i !== idx);
                                                                const newShapes = [...asset.shapes];
                                                                newShapes[targetIndex].points = newPts;
                                                                setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                                                                if (selectedPointIndex === idx) setSelectedPointIndex(null);
                                                            }} className="text-[10px] text-red-400 hover:text-red-600 p-0.5" title="ÂâäÈô§">√ó</button>
                                                        </div>
                                                    </div>
                                                    {/* È†ÇÁÇπÈñì„ÅÆÊìç‰Ωú„Éú„Çø„É≥ */}
                                                    <div className="flex flex-col items-center py-1 gap-0.5 bg-gray-50 rounded my-0.5">
                                                        <div className="text-[8px] text-gray-400">Ëæ∫ {idx}‚Üí{(idx + 1) % selectedShape.points.length}</div>
                                                        <div className="flex gap-1">
                                                            <button onClick={() => {
                                                                const nextIdx = (idx + 1) % selectedShape.points.length;
                                                                const nextPt = selectedShape.points[nextIdx];
                                                                const newPt = { x: (pt.x + nextPt.x) / 2, y: (pt.y + nextPt.y) / 2, handles: [] };
                                                                const newPts = [...selectedShape.points.slice(0, idx + 1), newPt, ...selectedShape.points.slice(idx + 1)];
                                                                const newShapes = [...asset.shapes];
                                                                newShapes[targetIndex].points = newPts;
                                                                setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                                                            }} className="text-[9px] text-green-600 hover:bg-green-100 px-1.5 py-0.5 rounded border border-green-300" title="È†ÇÁÇπ„ÇíËøΩÂä†">
                                                                +È†ÇÁÇπ
                                                            </button>
                                                            {(!pt.handles || pt.handles.length < 2) && (
                                                                <button onClick={() => {
                                                                    const newPts = [...selectedShape.points];
                                                                    const handles = newPts[idx].handles || [];
                                                                    const nextIdx = (idx + 1) % selectedShape.points.length;
                                                                    const nextPt = selectedShape.points[nextIdx];
                                                                    // Êñ∞„Åó„ÅÑÂà∂Âæ°ÁÇπ„ÇíËæ∫„ÅÆ‰∏≠Èñì„Å´ËøΩÂä†
                                                                    const t = (handles.length + 1) / 3; // 1„Å§ÁõÆ„ÅØ1/3„ÄÅ2„Å§ÁõÆ„ÅØ2/3„ÅÆ‰ΩçÁΩÆ
                                                                    const midX = pt.x + (nextPt.x - pt.x) * t;
                                                                    const midY = pt.y + (nextPt.y - pt.y) * t - 15;
                                                                    newPts[idx] = { ...newPts[idx], handles: [...handles, { x: midX, y: midY }] };
                                                                    const newShapes = [...asset.shapes];
                                                                    newShapes[targetIndex].points = newPts;
                                                                    setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                                                                }} className="text-[9px] text-blue-600 hover:bg-blue-100 px-1.5 py-0.5 rounded border border-blue-300" title="Êõ≤Á∑öÂà∂Âæ°ÁÇπ„ÇíËøΩÂä†">
                                                                    +Êõ≤Á∑ö{pt.handles?.length === 1 ? '2' : ''}
                                                                </button>
                                                            )}
                                                            {(pt.handles?.length > 0) && (
                                                                <button onClick={() => {
                                                                    const newPts = [...selectedShape.points];
                                                                    const handles = [...(newPts[idx].handles || [])];
                                                                    handles.pop(); // ÊúÄÂæå„ÅÆÂà∂Âæ°ÁÇπ„ÇíÂâäÈô§
                                                                    newPts[idx] = { ...newPts[idx], handles };
                                                                    const newShapes = [...asset.shapes];
                                                                    newShapes[targetIndex].points = newPts;
                                                                    setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                                                                }} className="text-[9px] text-red-500 hover:bg-red-100 px-1 py-0.5 rounded border border-red-300" title="Âà∂Âæ°ÁÇπ„ÇíÂâäÈô§">
                                                                    -{pt.handles.length}Êõ≤
                                                                </button>
                                                            )}
                                                        </div>
                                                        {/* Âà∂Âæ°ÁÇπÂ∫ßÊ®ôÂÖ•Âäõ */}
                                                        {pt.handles && pt.handles.length > 0 && (
                                                            <div className="mt-1 space-y-0.5">
                                                                {pt.handles.map((h, hid) => (
                                                                    <div key={hid} className="flex items-center gap-1 bg-orange-50 rounded px-1 py-0.5">
                                                                        <span className="text-[8px] text-orange-500 font-bold w-4">C{hid + 1}</span>
                                                                        <input type="number" value={toMM(h.x)} onChange={e => {
                                                                            const newPts = [...selectedShape.points];
                                                                            const handles = [...newPts[idx].handles];
                                                                            handles[hid] = { ...handles[hid], x: fromMM(Number(e.target.value)) };
                                                                            newPts[idx] = { ...newPts[idx], handles };
                                                                            const newShapes = [...asset.shapes];
                                                                            newShapes[targetIndex].points = newPts;
                                                                            setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                                                                        }} className="flex-1 text-[9px] p-0.5 border rounded w-10 text-center" placeholder="X" />
                                                                        <input type="number" value={toMM(h.y)} onChange={e => {
                                                                            const newPts = [...selectedShape.points];
                                                                            const handles = [...newPts[idx].handles];
                                                                            handles[hid] = { ...handles[hid], y: fromMM(Number(e.target.value)) };
                                                                            newPts[idx] = { ...newPts[idx], handles };
                                                                            const newShapes = [...asset.shapes];
                                                                            newShapes[targetIndex].points = newPts;
                                                                            setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a));
                                                                        }} className="flex-1 text-[9px] p-0.5 border rounded w-10 text-center" placeholder="Y" />
                                                                    </div>
                                                                ))}
                                                            </div>
                                                        )}
                                                    </div>
                                                </React.Fragment>
                                            ))}
                                        </div>
                                    </div>
                                )}
                            </div>
                        ) : (
                            <div className="text-xs text-gray-400 p-2 text-center border rounded border-dashed">„Ç≠„É£„É≥„Éê„Çπ‰∏ä„ÅÆ„Éë„Éº„ÉÑ„Çí„ÇØ„É™„ÉÉ„ÇØ„Åó„Å¶Á∑®ÈõÜ<br />ËÉåÊôØÂ∑¶„Éâ„É©„ÉÉ„Ç∞„ÅßÁØÑÂõ≤ÈÅ∏Êäû<br />Ctrl+„ÇØ„É™„ÉÉ„ÇØ„ÅßË§áÊï∞ÈÅ∏Êäû</div>
                        )}

                        {/* Structure List */}
                        <div className="mt-4 border-t pt-2">
                            <div className="flex justify-between items-center mb-2">
                                <label className="text-xs font-bold text-gray-500">ÊßãÊàêË¶ÅÁ¥†</label>
                                <div className="flex gap-1">
                                    <button onClick={() => setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: [...(a.shapes || []), { type: 'polygon', points: createRectPath(40, 40, 0, 0), color: asset.color }] } : a))} className="px-1.5 py-0.5 bg-gray-100 rounded hover:bg-gray-200 text-[10px]">‚ñ°</button>
                                    <button onClick={() => setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: [...(a.shapes || []), { type: 'polygon', points: createTrianglePath(40, 40, 0, 0), color: asset.color }] } : a))} className="px-1.5 py-0.5 bg-gray-100 rounded hover:bg-gray-200 text-[10px]">‚ñΩ</button>
                                    <button onClick={() => setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: [...(a.shapes || []), { type: 'ellipse', cx: 30, cy: 30, rx: 30, ry: 30, startAngle: 0, endAngle: 360, arcMode: 'sector', color: asset.color }] } : a))} className="px-1.5 py-0.5 bg-green-100 rounded hover:bg-green-200 text-[10px]" title="Ê•ïÂÜÜ/ÊâáÂΩ¢">‚óî</button>
                                </div>
                            </div>
                            <div className="space-y-1 max-h-32 overflow-y-auto scrollbar-thin">
                                {(asset.shapes || []).map((s, i) => (
                                    <div key={i}
                                        onClick={(e) => {
                                            if (e.ctrlKey || e.metaKey) {
                                                // „Éà„Ç∞„É´
                                                if (selectedShapeIndices.includes(i)) setSelectedShapeIndices(prev => prev.filter(idx => idx !== i));
                                                else setSelectedShapeIndices(prev => [...prev, i]);
                                            } else {
                                                setSelectedShapeIndices([i]);
                                            }
                                            setSelectedPointIndex(null);
                                        }}
                                        className={`flex justify-between items-center text-xs p-1 rounded border cursor-pointer ${selectedShapeIndices.includes(i) ? 'bg-blue-50 border-blue-300' : 'hover:bg-gray-50'}`}
                                    >
                                        <span className="font-bold text-gray-500">#{i + 1} {s.type}</span>
                                        <button onClick={(e) => { e.stopPropagation(); if (!confirm('ÂâäÈô§Ôºü')) return; const newShapes = asset.shapes.filter((_, idx) => idx !== i); setLocalAssets(p => p.map(a => a.id === designTargetId ? { ...a, shapes: newShapes } : a)); setSelectedShapeIndices(p => p.filter(idx => idx !== i)); }} className="text-red-400 hover:text-red-600 px-1">√ó</button>
                                    </div>
                                ))}
                            </div>
                        </div>

                        <div className="pt-4 border-t space-y-2">
                            <button onClick={fork} className="btn-action bg-blue-50 border border-blue-200 text-blue-600 hover:bg-blue-100">
                                <Icon p={Icons.Copy} size={14} /> „Ç≥„Éî„Éº„Åó„Å¶‰øùÂ≠ò
                            </button>
                            <button onClick={publish} className="btn-action bg-white border border-blue-200 text-blue-600 hover:bg-blue-50">
                                <Icon p={Icons.Globe} size={14} /> ÂÖ±ÈÄö„É©„Ç§„Éñ„É©„É™„Å´ÁôªÈå≤
                            </button>
                        </div>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [projects, setProjects] = useState([]);
            const [currentProjectId, setCurrentProjectId] = useState(null);
            const [mode, setMode] = useState('layout');
            const [viewState, setViewState] = useState({ x: 50, y: 50, scale: 1 });
            const [localAssets, setLocalAssets] = useState([]);
            const [globalAssets, setGlobalAssets] = useState([]);
            const [instances, setInstances] = useState([]);

            const [selectedIds, setSelectedIds] = useState([]);
            const [designTargetId, setDesignTargetId] = useState(null);
            const [selectedShapeIndices, setSelectedShapeIndices] = useState([]); // Ë§áÊï∞ÈÅ∏ÊäûÂØæÂøú
            const [selectedPointIndex, setSelectedPointIndex] = useState(null);
            const [colorPalette, setColorPalette] = useState([]);

            // URL„Éë„Çπ„Åã„ÇâÁèæÂú®„ÅÆ„Éö„Éº„Ç∏„ÇíÂà§ÂÆö
            const currentPath = window.location.pathname;
            const isLibraryPage = currentPath === '/library' || currentPath === '/library/';

            // „Éë„É¨„ÉÉ„Éà„Å´Ëâ≤„ÇíËøΩÂä†
            const addToPalette = (color) => {
                if (!colorPalette.includes(color)) {
                    const newPalette = [...colorPalette, color];
                    setColorPalette(newPalette);
                    API.savePalette({ colors: newPalette });
                }
            };

            // ÂàùÊúü„É≠„Éº„Éâ
            useEffect(() => {
                API.getProjects().then(setProjects);
                // „Ç∞„É≠„Éº„Éê„É´„Ç¢„Çª„ÉÉ„Éà„Å´source: 'global'„Çí‰ªò‰∏é
                API.getAssets().then(assets => setGlobalAssets(assets.map(a => ({ ...a, source: 'global' }))));
                // „Ç´„É©„Éº„Éë„É¨„ÉÉ„Éà„ÇíË™≠„ÅøËæº„Åø
                API.getPalette().then(data => setColorPalette(data.colors || []));
            }, []);

            // „Ç≠„Éº„Éú„Éº„Éâ„Éë„É≥ÔºàWASD / Áü¢Âç∞„Ç≠„ÉºÔºâ
            useEffect(() => {
                const PAN_STEP = 50;
                const handleKeyDown = (e) => {
                    // ÂÖ•Âäõ„Éï„Ç£„Éº„É´„Éâ„Å´„Éï„Ç©„Éº„Ç´„Çπ„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØÁÑ°Ë¶ñ
                    if (['INPUT', 'TEXTAREA', 'SELECT'].includes(e.target.tagName)) return;

                    let dx = 0, dy = 0;
                    switch (e.key.toLowerCase()) {
                        case 'w': case 'arrowup': dy = PAN_STEP; break;
                        case 's': case 'arrowdown': dy = -PAN_STEP; break;
                        case 'a': case 'arrowleft': dx = PAN_STEP; break;
                        case 'd': case 'arrowright': dx = -PAN_STEP; break;
                        default: return;
                    }
                    e.preventDefault();
                    setViewState(p => ({ ...p, x: p.x + dx, y: p.y + dy }));
                };
                window.addEventListener('keydown', handleKeyDown);
                return () => window.removeEventListener('keydown', handleKeyDown);
            }, []);

            // Êï∞ÂÄ§ÂÖ•Âäõ„ÅÆ„Éõ„Ç§„Éº„É´Êìç‰ΩúÔºàShiftÊäº‰∏ã„Åß10ÂÄçÔºâ
            useEffect(() => {
                const handleWheel = (e) => {
                    if (e.target.tagName === 'INPUT' && e.target.type === 'number') {
                        e.preventDefault();
                        const step = e.shiftKey ? 1000 : 10;
                        const delta = e.deltaY < 0 ? step : -step;
                        const currentValue = parseFloat(e.target.value) || 0;
                        const newValue = currentValue + delta;
                        e.target.value = newValue;
                        e.target.dispatchEvent(new Event('input', { bubbles: true }));
                        e.target.dispatchEvent(new Event('change', { bubbles: true }));
                    }
                };
                window.addEventListener('wheel', handleWheel, { passive: false });
                return () => window.removeEventListener('wheel', handleWheel);
            }, []);
            useEffect(() => {
                if (!currentProjectId) return;
                API.getProjectData(currentProjectId).then(data => {
                    let loadedAssets = data.assets || [];

                    // „Ç∞„É≠„Éº„Éê„É´„Ç¢„Çª„ÉÉ„Éà„ÇíËá™ÂãïÁöÑ„Å´„É≠„Éº„Ç´„É´„Å´„Éï„Ç©„Éº„ÇØ
                    // Êó¢„Å´Âêå„ÅòÂêçÂâç„ÅÆ„É≠„Éº„Ç´„É´„Ç¢„Çª„ÉÉ„Éà„Åå„Å™„Åë„Çå„Å∞„Ç≥„Éî„Éº„Çí‰ΩúÊàê
                    const localAssetNames = new Set(loadedAssets.map(a => a.name));
                    const forkedAssets = globalAssets
                        .filter(ga => !localAssetNames.has(ga.name))
                        .map(ga => ({ ...ga, id: `a-fork-${ga.id}-${Date.now()}`, source: undefined }));

                    setLocalAssets([...loadedAssets, ...forkedAssets]);
                    setInstances(data.instances || []);
                });
            }, [currentProjectId, globalAssets]);

            // Ëá™Âãï‰øùÂ≠ò (Á∞°Êòì)
            useEffect(() => {
                if (!currentProjectId) return;
                const timer = setTimeout(() => {
                    API.saveProjectData(currentProjectId, { assets: localAssets, instances });
                }, 1000);
                return () => clearTimeout(timer);
            }, [localAssets, instances, currentProjectId]);

            const handleCreateProject = async () => {
                const name = prompt("„Éó„É≠„Ç∏„Çß„ÇØ„ÉàÂêç„ÇíÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑ", "Êñ∞Ë¶è„Éó„É≠„Ç∏„Çß„ÇØ„Éà");
                if (!name) return;
                const newProj = await API.createProject(name);
                setProjects(p => [...p, newProj]);
            };

            const handleDeleteProject = async (e, id) => {
                e.stopPropagation();
                if (!confirm("„Åì„ÅÆ„Éó„É≠„Ç∏„Çß„ÇØ„Éà„ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü")) return;
                await API.deleteProject(id);
                setProjects(p => p.filter(proj => proj.id !== id));
            };

            const handleRenameProject = async (id, name) => {
                await API.updateProjectName(id, name);
                setProjects(p => p.map(proj => proj.id === id ? { ...proj, name } : proj));
            };

            const handleAddInstance = (assetId) => {
                let asset = [...localAssets, ...globalAssets].find(a => a.id === assetId);
                let targetAssetId = assetId;

                // „Ç∞„É≠„Éº„Éê„É´„Ç¢„Çª„ÉÉ„Éà„ÅÆÂ†¥Âêà„ÄÅËá™ÂãïÁöÑ„Å´„É≠„Éº„Ç´„É´„Ç≥„Éî„Éº„Çí‰ΩúÊàê
                if (asset && asset.source === 'global') {
                    const newLocalId = `a-fork-${Date.now()}`;
                    const newLocalAsset = { ...asset, id: newLocalId, name: asset.name, source: undefined };
                    setLocalAssets(prev => [...prev, newLocalAsset]);
                    targetAssetId = newLocalId;
                    asset = newLocalAsset;
                }

                const newInst = {
                    id: `i-${Date.now()}`,
                    assetId: targetAssetId,
                    x: (400 - viewState.x) / viewState.scale / BASE_SCALE,
                    y: (300 - viewState.y) / viewState.scale / BASE_SCALE,
                    rotation: 0,
                    locked: false,
                    type: asset ? asset.type : 'unknown'
                };
                setInstances(prev => [...prev, newInst]);
                setSelectedIds([newInst.id]);
            };

            const handleAddText = () => {
                const newInst = {
                    id: `t-${Date.now()}`,
                    type: 'text',
                    text: '„ÉÜ„Ç≠„Çπ„Éà',
                    fontSize: 24,
                    color: '#333333',
                    x: (400 - viewState.x) / viewState.scale / BASE_SCALE,
                    y: (300 - viewState.y) / viewState.scale / BASE_SCALE,
                    rotation: 0,
                    locked: false
                };
                setInstances(prev => [...prev, newInst]);
                setSelectedIds([newInst.id]);
            };

            // „É©„Ç§„Éñ„É©„É™ÁÆ°ÁêÜÁîªÈù¢
            if (isLibraryPage) {
                return (
                    <div className="min-h-screen bg-gray-100 overflow-auto">
                        {/* Header */}
                        <div className="bg-white border-b shadow-sm p-4 flex items-center justify-between">
                            <div className="flex items-center gap-4">
                                <a href="/" className="text-gray-500 hover:text-gray-800 flex items-center gap-2">
                                    <Icon p={Icons.LogOut} /> Êàª„Çã
                                </a>
                                <h1 className="text-xl font-bold text-gray-800">ÂÖ±ÈÄö„É©„Ç§„Éñ„É©„É™ÁÆ°ÁêÜ</h1>
                            </div>
                        </div>

                        <div className="max-w-4xl mx-auto p-6 space-y-8">
                            {/* „Ç´„É©„Éº„Éë„É¨„ÉÉ„ÉàÁÆ°ÁêÜ */}
                            <div className="bg-white rounded-lg shadow p-6">
                                <h2 className="text-lg font-bold text-gray-700 mb-4 flex items-center gap-2">
                                    üé® „Ç´„É©„Éº„Éë„É¨„ÉÉ„Éà
                                </h2>
                                <div className="grid grid-cols-10 gap-2 mb-4">
                                    {colorPalette.map((color, i) => (
                                        <div key={i} className="relative group">
                                            <div
                                                className="w-10 h-10 rounded border-2 border-gray-300"
                                                style={{ backgroundColor: color }}
                                                title={color}
                                            />
                                            <button
                                                onClick={() => {
                                                    const newPalette = colorPalette.filter((_, idx) => idx !== i);
                                                    setColorPalette(newPalette);
                                                    API.savePalette({ colors: newPalette });
                                                }}
                                                className="absolute -top-1 -right-1 w-4 h-4 bg-red-500 text-white rounded-full text-[10px] opacity-0 group-hover:opacity-100 transition"
                                            >
                                                √ó
                                            </button>
                                        </div>
                                    ))}
                                    {/* Êñ∞Ë¶èËâ≤ËøΩÂä† */}
                                    <label className="w-10 h-10 rounded border-2 border-dashed border-gray-300 flex items-center justify-center cursor-pointer hover:border-blue-400 hover:bg-blue-50 transition">
                                        <input
                                            type="color"
                                            className="sr-only"
                                            onChange={(e) => {
                                                const newColor = e.target.value;
                                                if (!colorPalette.includes(newColor)) {
                                                    const newPalette = [...colorPalette, newColor];
                                                    setColorPalette(newPalette);
                                                    API.savePalette({ colors: newPalette });
                                                }
                                            }}
                                        />
                                        <Icon p={Icons.Plus} size={16} className="text-gray-400" />
                                    </label>
                                </div>
                                <p className="text-xs text-gray-400">„ÇØ„É™„ÉÉ„ÇØ„ÅßÂâäÈô§„ÄÅ+ „Éú„Çø„É≥„ÅßÊñ∞„Åó„ÅÑËâ≤„ÇíËøΩÂä†</p>
                            </div>

                            {/* ÂÖ±ÈÄö„Ç¢„Çª„ÉÉ„ÉàÁÆ°ÁêÜ */}
                            <div className="bg-white rounded-lg shadow p-6">
                                <div className="flex items-center justify-between mb-4">
                                    <h2 className="text-lg font-bold text-gray-700 flex items-center gap-2">
                                        üì¶ ÂÖ±ÈÄö„Ç¢„Çª„ÉÉ„Éà
                                    </h2>
                                    <button
                                        onClick={async () => {
                                            try {
                                                const data = globalAssets.map(a => ({ ...a, source: undefined }));
                                                console.log('Saving assets:', data);
                                                const res = await API.saveAssets(data);
                                                console.log('Save response:', res);
                                                alert('ÂÖ±ÈÄö„Ç¢„Çª„ÉÉ„Éà„Çí‰øùÂ≠ò„Åó„Åæ„Åó„Åü');
                                            } catch (e) {
                                                console.error('Save failed:', e);
                                                alert('‰øùÂ≠ò„Å´Â§±Êïó„Åó„Åæ„Åó„Åü: ' + e.message);
                                            }
                                        }}
                                        className="text-xs bg-green-50 text-green-600 px-3 py-1 rounded border border-green-200 hover:bg-green-100"
                                    >
                                        Â§âÊõ¥„Çí‰øùÂ≠ò
                                    </button>
                                </div>
                                <div className="flex gap-6">
                                    {/* „Ç¢„Çª„ÉÉ„Éà‰∏ÄË¶ß */}
                                    <div className="flex-1">
                                        <div className="grid grid-cols-3 gap-3">
                                            {globalAssets.map(asset => (
                                                <div
                                                    key={asset.id}
                                                    onClick={() => setDesignTargetId(designTargetId === asset.id ? null : asset.id)}
                                                    className={`border rounded p-3 relative group cursor-pointer transition ${designTargetId === asset.id
                                                        ? 'bg-blue-50 border-blue-400 ring-2 ring-blue-200'
                                                        : 'bg-gray-50 hover:bg-gray-100'
                                                        }`}
                                                >
                                                    <div className="w-10 h-10 mx-auto rounded mb-2 border" style={{ backgroundColor: asset.color }} />
                                                    <div className="text-xs font-bold text-gray-700 text-center truncate">{asset.name}</div>
                                                    <div className="text-[10px] text-gray-400 text-center">{asset.type}</div>
                                                    <button
                                                        onClick={(e) => {
                                                            e.stopPropagation();
                                                            if (!confirm(`"${asset.name}" „ÇíÂâäÈô§„Åó„Åæ„Åô„ÅãÔºü`)) return;
                                                            const newAssets = globalAssets.filter(a => a.id !== asset.id);
                                                            setGlobalAssets(newAssets);
                                                            API.saveAssets(newAssets.map(a => ({ ...a, source: undefined })));
                                                            if (designTargetId === asset.id) setDesignTargetId(null);
                                                        }}
                                                        className="absolute top-1 right-1 text-gray-300 hover:text-red-500 opacity-0 group-hover:opacity-100 transition p-1"
                                                    >
                                                        <Icon p={Icons.Trash} size={12} />
                                                    </button>
                                                </div>
                                            ))}
                                        </div>
                                        {globalAssets.length === 0 && (
                                            <div className="text-center py-8 text-gray-400">
                                                ÂÖ±ÈÄö„Ç¢„Çª„ÉÉ„Éà„ÅØ„Åæ„Å†„ÅÇ„Çä„Åæ„Åõ„Çì
                                            </div>
                                        )}
                                    </div>

                                    {/* Á∑®ÈõÜ„Éë„Éç„É´ */}
                                    {designTargetId && (() => {
                                        const editAsset = globalAssets.find(a => a.id === designTargetId);
                                        if (!editAsset) return null;
                                        const updateAsset = (key, value) => {
                                            const newAssets = globalAssets.map(a =>
                                                a.id === designTargetId ? { ...a, [key]: value } : a
                                            );
                                            setGlobalAssets(newAssets);
                                        };
                                        return (
                                            <div className="w-64 bg-gray-50 border rounded-lg p-4 space-y-4">
                                                <div className="flex items-center justify-between">
                                                    <h3 className="font-bold text-sm text-gray-700">„Ç¢„Çª„ÉÉ„ÉàÁ∑®ÈõÜ</h3>
                                                    <button onClick={() => setDesignTargetId(null)} className="text-gray-400 hover:text-gray-600">√ó</button>
                                                </div>

                                                {/* „Éó„É¨„Éì„É•„Éº */}
                                                <div className="flex justify-center">
                                                    <div className="w-20 h-20 rounded border-2" style={{ backgroundColor: editAsset.color }} />
                                                </div>

                                                {/* ÂêçÁß∞ */}
                                                <div>
                                                    <label className="text-xs font-bold text-gray-500 block mb-1">ÂêçÁß∞</label>
                                                    <input
                                                        value={editAsset.name}
                                                        onChange={e => updateAsset('name', e.target.value)}
                                                        className="w-full px-2 py-1 border rounded text-sm"
                                                    />
                                                </div>

                                                {/* Á®ÆÈ°û */}
                                                <div>
                                                    <label className="text-xs font-bold text-gray-500 block mb-1">Á®ÆÈ°û</label>
                                                    <select
                                                        value={editAsset.type}
                                                        onChange={e => updateAsset('type', e.target.value)}
                                                        className="w-full px-2 py-1 border rounded text-sm"
                                                    >
                                                        <option value="room">ÈÉ®Â±ã„ÉªÂ∫ä</option>
                                                        <option value="fixture">Ë®≠ÂÇô„ÉªÂª∫ÂÖ∑</option>
                                                        <option value="furniture">ÂÆ∂ÂÖ∑</option>
                                                    </select>
                                                </div>

                                                {/* Ëâ≤ */}
                                                <div>
                                                    <label className="text-xs font-bold text-gray-500 block mb-1">Ëâ≤</label>
                                                    <ColorPicker
                                                        value={editAsset.color}
                                                        onChange={c => updateAsset('color', c)}
                                                        palette={colorPalette}
                                                        onAddToPalette={addToPalette}
                                                    />
                                                </div>

                                                {/* „Çµ„Ç§„Ç∫ */}
                                                <div className="grid grid-cols-2 gap-2">
                                                    <div>
                                                        <label className="text-xs font-bold text-gray-500 block mb-1">ÂπÖ (mm)</label>
                                                        <input
                                                            type="number"
                                                            value={editAsset.w || 100}
                                                            onChange={e => updateAsset('w', Number(e.target.value))}
                                                            className="w-full px-2 py-1 border rounded text-sm"
                                                        />
                                                    </div>
                                                    <div>
                                                        <label className="text-xs font-bold text-gray-500 block mb-1">È´ò„Åï (mm)</label>
                                                        <input
                                                            type="number"
                                                            value={editAsset.h || 100}
                                                            onChange={e => updateAsset('h', Number(e.target.value))}
                                                            className="w-full px-2 py-1 border rounded text-sm"
                                                        />
                                                    </div>
                                                </div>

                                                {/* ‰øùÂ≠ò„Éú„Çø„É≥ */}
                                                <button
                                                    onClick={() => {
                                                        API.saveAssets(globalAssets.map(a => ({ ...a, source: undefined })));
                                                        alert('‰øùÂ≠ò„Åó„Åæ„Åó„Åü');
                                                    }}
                                                    className="w-full bg-blue-600 text-white text-sm py-2 rounded hover:bg-blue-700 transition"
                                                >
                                                    ‰øùÂ≠ò
                                                </button>
                                            </div>
                                        );
                                    })()}
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            if (!currentProjectId) {
                return (
                    <div className="p-8 bg-gray-100 min-h-screen">
                        <div className="max-w-4xl mx-auto">
                            <div className="flex items-center justify-between mb-6">
                                <h1 className="text-2xl font-bold text-gray-700">„Éó„É≠„Ç∏„Çß„ÇØ„Éà‰∏ÄË¶ß</h1>
                                <a href="/library" className="text-sm text-blue-600 hover:underline flex items-center gap-1">
                                    <Icon p={Icons.Settings} size={14} /> ÂÖ±ÈÄö„É©„Ç§„Éñ„É©„É™ÁÆ°ÁêÜ
                                </a>
                            </div>
                            <div className="grid grid-cols-4 gap-4">
                                <div onClick={handleCreateProject} className="h-40 border-2 border-dashed border-gray-300 rounded-lg flex flex-col items-center justify-center text-gray-400 cursor-pointer hover:bg-gray-50 hover:border-blue-400 hover:text-blue-500 transition">
                                    <Icon p={Icons.Plus} size={32} />
                                    <span className="mt-2 font-bold">Êñ∞Ë¶è‰ΩúÊàê</span>
                                </div>
                                {projects.map(p => (
                                    <ProjectCard key={p.id} project={p} onOpen={() => setCurrentProjectId(p.id)} onDelete={handleDeleteProject} onRename={handleRenameProject} />
                                ))}
                            </div>
                        </div>
                    </div>
                );
            }

            const activeProject = projects.find(p => p.id === currentProjectId);

            // ÂÖ±ÈÄö„Ç¢„Çª„ÉÉ„ÉàID„Åã„Çâ„Ç¢„Çª„ÉÉ„Éà„ÇíÂèñÂæóÔºà„Åæ„Åü„ÅØ„É≠„Éº„Ç´„É´„ÇíÂê´„ÇÅ„Å¶Ê§úÁ¥¢Ôºâ
            const allAssets = [...localAssets, ...globalAssets];

            return (
                <div className="flex h-screen overflow-hidden">
                    {/* Size: 260px Sidebar */}
                    <div className="w-64 flex-shrink-0 border-r bg-white flex flex-col z-20 shadow-sm">
                        <div className="p-3 border-b flex items-center justify-between bg-gray-50">
                            <button onClick={() => setCurrentProjectId(null)} className="text-gray-500 hover:text-gray-800 p-1 rounded hover:bg-gray-200"><Icon p={Icons.LogOut} /></button>
                            <span className="font-bold text-sm truncate px-2">{activeProject?.name}</span>
                            <div className="w-6"></div>
                        </div>
                        <UnifiedSidebar
                            mode={mode}
                            assets={localAssets}
                            onAddInstance={handleAddInstance}
                            onAddText={handleAddText}
                            setLocalAssets={setLocalAssets}
                            setGlobalAssets={setGlobalAssets}
                            setDesignTargetId={setDesignTargetId}
                            designTargetId={designTargetId}
                            instances={instances}
                            setInstances={setInstances}
                        />
                    </div>

                    {/* Main Canvas */}
                    <div className="flex-1 relative bg-gray-100 overflow-hidden relative">
                        <div className={`absolute inset-0 ${mode === 'layout' ? 'grid-bg' : 'design-grid'}`}></div>

                        {/* Toolbar - „É´„Éº„É©„Éº„ÅÆ‰∏ã„Å´ÈÖçÁΩÆ */}
                        <div className="absolute top-6 left-6 z-30 bg-white p-1 rounded shadow-md border flex gap-1">
                            <button onClick={() => setMode('layout')} className={`px-3 py-1.5 rounded text-xs font-bold flex items-center gap-2 ${mode === 'layout' ? 'bg-blue-100 text-blue-700' : 'text-gray-500 hover:bg-gray-50'}`}>
                                <Icon p={Icons.Move} size={14} /> „É¨„Ç§„Ç¢„Ç¶„Éà
                            </button>
                            <button onClick={() => { setMode('design'); if (!designTargetId && localAssets.length > 0) setDesignTargetId(localAssets[0].id); }} className={`px-3 py-1.5 rounded text-xs font-bold flex items-center gap-2 ${mode === 'design' ? 'bg-orange-100 text-orange-700' : 'text-gray-500 hover:bg-gray-50'}`}>
                                <Icon p={Icons.Pen} size={14} /> „Éë„Éº„ÉÑË®≠Ë®à
                            </button>
                        </div>

                        {/* Scale Controls */}
                        <div className="absolute bottom-4 left-4 z-30 bg-white p-1 rounded shadow-md border flex gap-1">
                            <button onClick={() => setViewState(p => ({ ...p, scale: p.scale * 1.2 }))} className="p-1.5 rounded hover:bg-gray-100 text-gray-600"><Icon p={Icons.ZoomIn} /></button>
                            <span className="px-2 py-1 text-xs min-w-[3rem] text-center">{Math.round(viewState.scale * 100)}%</span>
                            <button onClick={() => setViewState(p => ({ ...p, scale: p.scale / 1.2 }))} className="p-1.5 rounded hover:bg-gray-100 text-gray-600"><Icon p={Icons.ZoomOut} /></button>
                        </div>

                        <Ruler viewState={viewState} />

                        {mode === 'layout' ? (
                            <LayoutCanvas
                                viewState={viewState} setViewState={setViewState}
                                assets={allAssets}
                                instances={instances} setInstances={setInstances}
                                selectedIds={selectedIds} setSelectedIds={setSelectedIds}
                            />
                        ) : (
                            <DesignCanvas
                                viewState={viewState} setViewState={setViewState}
                                assets={allAssets}
                                designTargetId={designTargetId} setLocalAssets={setLocalAssets}
                                setGlobalAssets={setGlobalAssets}
                                selectedShapeIndices={selectedShapeIndices} setSelectedShapeIndices={setSelectedShapeIndices}
                                selectedPointIndex={selectedPointIndex} setSelectedPointIndex={setSelectedPointIndex}
                            />
                        )}
                    </div>

                    {/* Right Properties Panel */}
                    <div className="w-72 flex-shrink-0 border-l bg-white z-20 shadow-sm flex flex-col">
                        {mode === 'layout' ? (
                            <LayoutProperties
                                instances={instances} setInstances={setInstances}
                                selectedIds={selectedIds} assets={allAssets} setSelectedIds={setSelectedIds}
                                setMode={setMode} setDesignTargetId={setDesignTargetId}
                            />
                        ) : (
                            <DesignProperties
                                assets={allAssets} designTargetId={designTargetId}
                                setLocalAssets={setLocalAssets} setGlobalAssets={setGlobalAssets}
                                selectedShapeIndices={selectedShapeIndices} setSelectedShapeIndices={setSelectedShapeIndices}
                                selectedPointIndex={selectedPointIndex} setSelectedPointIndex={setSelectedPointIndex}
                                setDesignTargetId={setDesignTargetId}
                                palette={colorPalette} onAddToPalette={addToPalette}
                            />
                        )}
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

</html>